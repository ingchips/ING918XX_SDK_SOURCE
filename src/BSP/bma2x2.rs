/* automatically generated by rust-bindgen */

pub const BMA2x2_SPI_RD_MASK: u32 = 128;
pub const BMA2x2_I2C_ADDR1: u32 = 24;
pub const BMA2x2_I2C_ADDR2: u32 = 25;
pub const BMA2x2_I2C_ADDR3: u32 = 16;
pub const BMA2x2_I2C_ADDR4: u32 = 17;
pub const BMA2x2_FIFO_XYZ_DATA_ENABLED: u32 = 0;
pub const BMA2x2_FIFO_X_DATA_ENABLED: u32 = 1;
pub const BMA2x2_FIFO_Y_DATA_ENABLED: u32 = 2;
pub const BMA2x2_FIFO_Z_DATA_ENABLED: u32 = 3;
pub const BMA2x2_FIFO_DATA_ENABLED_MASK: u32 = 3;
pub const BMA2x2_EEP_OFFSET: u32 = 22;
pub const BMA2x2_IMAGE_BASE: u32 = 56;
pub const BMA2x2_IMAGE_LEN: u32 = 22;
pub const BMA2x2_CHIP_ID_ADDR: u32 = 0;
pub const BMA2x2_X_AXIS_LSB_ADDR: u32 = 2;
pub const BMA2x2_X_AXIS_MSB_ADDR: u32 = 3;
pub const BMA2x2_Y_AXIS_LSB_ADDR: u32 = 4;
pub const BMA2x2_Y_AXIS_MSB_ADDR: u32 = 5;
pub const BMA2x2_Z_AXIS_LSB_ADDR: u32 = 6;
pub const BMA2x2_Z_AXIS_MSB_ADDR: u32 = 7;
pub const BMA2x2_TEMP_ADDR: u32 = 8;
pub const BMA2x2_STAT1_ADDR: u32 = 9;
pub const BMA2x2_STAT2_ADDR: u32 = 10;
pub const BMA2x2_STAT_TAP_SLOPE_ADDR: u32 = 11;
pub const BMA2x2_STAT_ORIENT_HIGH_ADDR: u32 = 12;
pub const BMA2x2_STAT_FIFO_ADDR: u32 = 14;
pub const BMA2x2_RANGE_SELECT_ADDR: u32 = 15;
pub const BMA2x2_BW_SELECT_ADDR: u32 = 16;
pub const BMA2x2_MODE_CTRL_ADDR: u32 = 17;
pub const BMA2x2_LOW_NOISE_CTRL_ADDR: u32 = 18;
pub const BMA2x2_DATA_CTRL_ADDR: u32 = 19;
pub const BMA2x2_RST_ADDR: u32 = 20;
pub const BMA2x2_INTR_ENABLE1_ADDR: u32 = 22;
pub const BMA2x2_INTR_ENABLE2_ADDR: u32 = 23;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ADDR: u32 = 24;
pub const BMA2x2_INTR1_PAD_SELECT_ADDR: u32 = 25;
pub const BMA2x2_INTR_DATA_SELECT_ADDR: u32 = 26;
pub const BMA2x2_INTR2_PAD_SELECT_ADDR: u32 = 27;
pub const BMA2x2_INTR_SOURCE_ADDR: u32 = 30;
pub const BMA2x2_INTR_SET_ADDR: u32 = 32;
pub const BMA2x2_INTR_CTRL_ADDR: u32 = 33;
pub const BMA2x2_LOW_DURN_ADDR: u32 = 34;
pub const BMA2x2_LOW_THRES_ADDR: u32 = 35;
pub const BMA2x2_LOW_HIGH_HYST_ADDR: u32 = 36;
pub const BMA2x2_HIGH_DURN_ADDR: u32 = 37;
pub const BMA2x2_HIGH_THRES_ADDR: u32 = 38;
pub const BMA2x2_SLOPE_DURN_ADDR: u32 = 39;
pub const BMA2x2_SLOPE_THRES_ADDR: u32 = 40;
pub const BMA2x2_SLOW_NO_MOTION_THRES_ADDR: u32 = 41;
pub const BMA2x2_TAP_PARAM_ADDR: u32 = 42;
pub const BMA2x2_TAP_THRES_ADDR: u32 = 43;
pub const BMA2x2_ORIENT_PARAM_ADDR: u32 = 44;
pub const BMA2x2_THETA_BLOCK_ADDR: u32 = 45;
pub const BMA2x2_THETA_FLAT_ADDR: u32 = 46;
pub const BMA2x2_FLAT_HOLD_TIME_ADDR: u32 = 47;
pub const BMA2x2_SELFTEST_ADDR: u32 = 50;
pub const BMA2x2_EEPROM_CTRL_ADDR: u32 = 51;
pub const BMA2x2_SERIAL_CTRL_ADDR: u32 = 52;
pub const BMA2x2_OFFSET_CTRL_ADDR: u32 = 54;
pub const BMA2x2_OFFSET_PARAMS_ADDR: u32 = 55;
pub const BMA2x2_OFFSET_X_AXIS_ADDR: u32 = 56;
pub const BMA2x2_OFFSET_Y_AXIS_ADDR: u32 = 57;
pub const BMA2x2_OFFSET_Z_AXIS_ADDR: u32 = 58;
pub const BMA2x2_GP0_ADDR: u32 = 59;
pub const BMA2x2_GP1_ADDR: u32 = 60;
pub const BMA2x2_FIFO_MODE_ADDR: u32 = 62;
pub const BMA2x2_FIFO_DATA_OUTPUT_ADDR: u32 = 63;
pub const BMA2x2_FIFO_WML_TRIG: u32 = 48;
pub const BMA2x2_12_RESOLUTION: u32 = 0;
pub const BMA2x2_10_RESOLUTION: u32 = 1;
pub const BMA2x2_14_RESOLUTION: u32 = 2;
pub const BMA2x2_EE_W_DELAY: u32 = 28;
pub const BMA2x2_CHIP_ID_POS: u32 = 0;
pub const BMA2x2_CHIP_ID_MSK: u32 = 255;
pub const BMA2x2_CHIP_ID_LEN: u32 = 8;
pub const BMA2x2_CHIP_ID_REG: u32 = 0;
pub const BMA2x2_NEW_DATA_X_POS: u32 = 0;
pub const BMA2x2_NEW_DATA_X_LEN: u32 = 1;
pub const BMA2x2_NEW_DATA_X_MSK: u32 = 1;
pub const BMA2x2_NEW_DATA_X_REG: u32 = 2;
pub const BMA2x2_ACCEL_X14_LSB_POS: u32 = 2;
pub const BMA2x2_ACCEL_X14_LSB_LEN: u32 = 6;
pub const BMA2x2_ACCEL_X14_LSB_MSK: u32 = 252;
pub const BMA2x2_ACCEL_X14_LSB_REG: u32 = 2;
pub const BMA2x2_ACCEL_X12_LSB_POS: u32 = 4;
pub const BMA2x2_ACCEL_X12_LSB_LEN: u32 = 4;
pub const BMA2x2_ACCEL_X12_LSB_MSK: u32 = 240;
pub const BMA2x2_ACCEL_X12_LSB_REG: u32 = 2;
pub const BMA2x2_ACCEL_X10_LSB_POS: u32 = 6;
pub const BMA2x2_ACCEL_X10_LSB_LEN: u32 = 2;
pub const BMA2x2_ACCEL_X10_LSB_MSK: u32 = 192;
pub const BMA2x2_ACCEL_X10_LSB_REG: u32 = 2;
pub const BMA2x2_ACCEL_X8_LSB_POS: u32 = 0;
pub const BMA2x2_ACCEL_X8_LSB_LEN: u32 = 0;
pub const BMA2x2_ACCEL_X8_LSB_MSK: u32 = 0;
pub const BMA2x2_ACCEL_X8_LSB_REG: u32 = 2;
pub const BMA2x2_ACCEL_X_MSB_POS: u32 = 0;
pub const BMA2x2_ACCEL_X_MSB_LEN: u32 = 8;
pub const BMA2x2_ACCEL_X_MSB_MSK: u32 = 255;
pub const BMA2x2_ACCEL_X_MSB_REG: u32 = 3;
pub const BMA2x2_NEW_DATA_Y_POS: u32 = 0;
pub const BMA2x2_NEW_DATA_Y_LEN: u32 = 1;
pub const BMA2x2_NEW_DATA_Y_MSK: u32 = 1;
pub const BMA2x2_NEW_DATA_Y_REG: u32 = 4;
pub const BMA2x2_ACCEL_Y14_LSB_POS: u32 = 2;
pub const BMA2x2_ACCEL_Y14_LSB_LEN: u32 = 6;
pub const BMA2x2_ACCEL_Y14_LSB_MSK: u32 = 252;
pub const BMA2x2_ACCEL_Y14_LSB_REG: u32 = 4;
pub const BMA2x2_ACCEL_Y12_LSB_POS: u32 = 4;
pub const BMA2x2_ACCEL_Y12_LSB_LEN: u32 = 4;
pub const BMA2x2_ACCEL_Y12_LSB_MSK: u32 = 240;
pub const BMA2x2_ACCEL_Y12_LSB_REG: u32 = 4;
pub const BMA2x2_ACCEL_Y10_LSB_POS: u32 = 6;
pub const BMA2x2_ACCEL_Y10_LSB_LEN: u32 = 2;
pub const BMA2x2_ACCEL_Y10_LSB_MSK: u32 = 192;
pub const BMA2x2_ACCEL_Y10_LSB_REG: u32 = 4;
pub const BMA2x2_ACCEL_Y8_LSB_POS: u32 = 0;
pub const BMA2x2_ACCEL_Y8_LSB_LEN: u32 = 0;
pub const BMA2x2_ACCEL_Y8_LSB_MSK: u32 = 0;
pub const BMA2x2_ACCEL_Y8_LSB_REG: u32 = 4;
pub const BMA2x2_ACCEL_Y_MSB_POS: u32 = 0;
pub const BMA2x2_ACCEL_Y_MSB_LEN: u32 = 8;
pub const BMA2x2_ACCEL_Y_MSB_MSK: u32 = 255;
pub const BMA2x2_ACCEL_Y_MSB_REG: u32 = 5;
pub const BMA2x2_NEW_DATA_Z_POS: u32 = 0;
pub const BMA2x2_NEW_DATA_Z_LEN: u32 = 1;
pub const BMA2x2_NEW_DATA_Z_MSK: u32 = 1;
pub const BMA2x2_NEW_DATA_Z_REG: u32 = 6;
pub const BMA2x2_ACCEL_Z14_LSB_POS: u32 = 2;
pub const BMA2x2_ACCEL_Z14_LSB_LEN: u32 = 6;
pub const BMA2x2_ACCEL_Z14_LSB_MSK: u32 = 252;
pub const BMA2x2_ACCEL_Z14_LSB_REG: u32 = 6;
pub const BMA2x2_ACCEL_Z12_LSB_POS: u32 = 4;
pub const BMA2x2_ACCEL_Z12_LSB_LEN: u32 = 4;
pub const BMA2x2_ACCEL_Z12_LSB_MSK: u32 = 240;
pub const BMA2x2_ACCEL_Z12_LSB_REG: u32 = 6;
pub const BMA2x2_ACCEL_Z10_LSB_POS: u32 = 6;
pub const BMA2x2_ACCEL_Z10_LSB_LEN: u32 = 2;
pub const BMA2x2_ACCEL_Z10_LSB_MSK: u32 = 192;
pub const BMA2x2_ACCEL_Z10_LSB_REG: u32 = 6;
pub const BMA2x2_ACCEL_Z8_LSB_POS: u32 = 0;
pub const BMA2x2_ACCEL_Z8_LSB_LEN: u32 = 0;
pub const BMA2x2_ACCEL_Z8_LSB_MSK: u32 = 0;
pub const BMA2x2_ACCEL_Z8_LSB_REG: u32 = 6;
pub const BMA2x2_ACCEL_Z_MSB_POS: u32 = 0;
pub const BMA2x2_ACCEL_Z_MSB_LEN: u32 = 8;
pub const BMA2x2_ACCEL_Z_MSB_MSK: u32 = 255;
pub const BMA2x2_ACCEL_Z_MSB_REG: u32 = 7;
pub const BMA2x2_ACCEL_TEMP_MSB_POS: u32 = 0;
pub const BMA2x2_ACCEL_TEMP_MSB_LEN: u32 = 8;
pub const BMA2x2_ACCEL_TEMP_MSB_MSK: u32 = 255;
pub const BMA2x2_LOW_G_INTR_STAT_POS: u32 = 0;
pub const BMA2x2_LOW_G_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_LOW_G_INTR_STAT_MSK: u32 = 1;
pub const BMA2x2_LOW_G_INTR_STAT_REG: u32 = 9;
pub const BMA2x2_HIGH_G_INTR_STAT_POS: u32 = 1;
pub const BMA2x2_HIGH_G_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_HIGH_G_INTR_STAT_MSK: u32 = 2;
pub const BMA2x2_HIGH_G_INTR_STAT_REG: u32 = 9;
pub const BMA2x2_SLOPE_INTR_STAT_POS: u32 = 2;
pub const BMA2x2_SLOPE_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_SLOPE_INTR_STAT_MSK: u32 = 4;
pub const BMA2x2_SLOPE_INTR_STAT_REG: u32 = 9;
pub const BMA2x2_SLOW_NO_MOTION_INTR_STAT_POS: u32 = 3;
pub const BMA2x2_SLOW_NO_MOTION_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_SLOW_NO_MOTION_INTR_STAT_MSK: u32 = 8;
pub const BMA2x2_SLOW_NO_MOTION_INTR_STAT_REG: u32 = 9;
pub const BMA2x2_DOUBLE_TAP_INTR_STAT_POS: u32 = 4;
pub const BMA2x2_DOUBLE_TAP_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_DOUBLE_TAP_INTR_STAT_MSK: u32 = 16;
pub const BMA2x2_DOUBLE_TAP_INTR_STAT_REG: u32 = 9;
pub const BMA2x2_SINGLE_TAP_INTR_STAT_POS: u32 = 5;
pub const BMA2x2_SINGLE_TAP_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_SINGLE_TAP_INTR_STAT_MSK: u32 = 32;
pub const BMA2x2_SINGLE_TAP_INTR_STAT_REG: u32 = 9;
pub const BMA2x2_ORIENT_INTR_STAT_POS: u32 = 6;
pub const BMA2x2_ORIENT_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_ORIENT_INTR_STAT_MSK: u32 = 64;
pub const BMA2x2_ORIENT_INTR_STAT_REG: u32 = 9;
pub const BMA2x2_FLAT_INTR_STAT_POS: u32 = 7;
pub const BMA2x2_FLAT_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_FLAT_INTR_STAT_MSK: u32 = 128;
pub const BMA2x2_FLAT_INTR_STAT_REG: u32 = 9;
pub const BMA2x2_FIFO_FULL_INTR_STAT_POS: u32 = 5;
pub const BMA2x2_FIFO_FULL_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_FIFO_FULL_INTR_STAT_MSK: u32 = 32;
pub const BMA2x2_FIFO_FULL_INTR_STAT_REG: u32 = 10;
pub const BMA2x2_FIFO_WM_INTR_STAT_POS: u32 = 6;
pub const BMA2x2_FIFO_WM_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_FIFO_WM_INTR_STAT_MSK: u32 = 64;
pub const BMA2x2_FIFO_WM_INTR_STAT_REG: u32 = 10;
pub const BMA2x2_DATA_INTR_STAT_POS: u32 = 7;
pub const BMA2x2_DATA_INTR_STAT_LEN: u32 = 1;
pub const BMA2x2_DATA_INTR_STAT_MSK: u32 = 128;
pub const BMA2x2_DATA_INTR_STAT_REG: u32 = 10;
pub const BMA2x2_SLOPE_FIRST_X_POS: u32 = 0;
pub const BMA2x2_SLOPE_FIRST_X_LEN: u32 = 1;
pub const BMA2x2_SLOPE_FIRST_X_MSK: u32 = 1;
pub const BMA2x2_SLOPE_FIRST_X_REG: u32 = 11;
pub const BMA2x2_SLOPE_FIRST_Y_POS: u32 = 1;
pub const BMA2x2_SLOPE_FIRST_Y_LEN: u32 = 1;
pub const BMA2x2_SLOPE_FIRST_Y_MSK: u32 = 2;
pub const BMA2x2_SLOPE_FIRST_Y_REG: u32 = 11;
pub const BMA2x2_SLOPE_FIRST_Z_POS: u32 = 2;
pub const BMA2x2_SLOPE_FIRST_Z_LEN: u32 = 1;
pub const BMA2x2_SLOPE_FIRST_Z_MSK: u32 = 4;
pub const BMA2x2_SLOPE_FIRST_Z_REG: u32 = 11;
pub const BMA2x2_SLOPE_SIGN_STAT_POS: u32 = 3;
pub const BMA2x2_SLOPE_SIGN_STAT_LEN: u32 = 1;
pub const BMA2x2_SLOPE_SIGN_STAT_MSK: u32 = 8;
pub const BMA2x2_SLOPE_SIGN_STAT_REG: u32 = 11;
pub const BMA2x2_TAP_FIRST_X_POS: u32 = 4;
pub const BMA2x2_TAP_FIRST_X_LEN: u32 = 1;
pub const BMA2x2_TAP_FIRST_X_MSK: u32 = 16;
pub const BMA2x2_TAP_FIRST_X_REG: u32 = 11;
pub const BMA2x2_TAP_FIRST_Y_POS: u32 = 5;
pub const BMA2x2_TAP_FIRST_Y_LEN: u32 = 1;
pub const BMA2x2_TAP_FIRST_Y_MSK: u32 = 32;
pub const BMA2x2_TAP_FIRST_Y_REG: u32 = 11;
pub const BMA2x2_TAP_FIRST_Z_POS: u32 = 6;
pub const BMA2x2_TAP_FIRST_Z_LEN: u32 = 1;
pub const BMA2x2_TAP_FIRST_Z_MSK: u32 = 64;
pub const BMA2x2_TAP_FIRST_Z_REG: u32 = 11;
pub const BMA2x2_TAP_SIGN_STAT_POS: u32 = 7;
pub const BMA2x2_TAP_SIGN_STAT_LEN: u32 = 1;
pub const BMA2x2_TAP_SIGN_STAT_MSK: u32 = 128;
pub const BMA2x2_TAP_SIGN_STAT_REG: u32 = 11;
pub const BMA2x2_HIGH_G_FIRST_X_POS: u32 = 0;
pub const BMA2x2_HIGH_G_FIRST_X_LEN: u32 = 1;
pub const BMA2x2_HIGH_G_FIRST_X_MSK: u32 = 1;
pub const BMA2x2_HIGH_G_FIRST_X_REG: u32 = 12;
pub const BMA2x2_HIGH_G_FIRST_Y_POS: u32 = 1;
pub const BMA2x2_HIGH_G_FIRST_Y_LEN: u32 = 1;
pub const BMA2x2_HIGH_G_FIRST_Y_MSK: u32 = 2;
pub const BMA2x2_HIGH_G_FIRST_Y_REG: u32 = 12;
pub const BMA2x2_HIGH_G_FIRST_Z_POS: u32 = 2;
pub const BMA2x2_HIGH_G_FIRST_Z_LEN: u32 = 1;
pub const BMA2x2_HIGH_G_FIRST_Z_MSK: u32 = 4;
pub const BMA2x2_HIGH_G_FIRST_Z_REG: u32 = 12;
pub const BMA2x2_HIGH_G_SIGN_STAT_POS: u32 = 3;
pub const BMA2x2_HIGH_G_SIGN_STAT_LEN: u32 = 1;
pub const BMA2x2_HIGH_G_SIGN_STAT_MSK: u32 = 8;
pub const BMA2x2_HIGH_G_SIGN_STAT_REG: u32 = 12;
pub const BMA2x2_ORIENT_STAT_POS: u32 = 4;
pub const BMA2x2_ORIENT_STAT_LEN: u32 = 3;
pub const BMA2x2_ORIENT_STAT_MSK: u32 = 112;
pub const BMA2x2_ORIENT_STAT_REG: u32 = 12;
pub const BMA2x2_FLAT_STAT_POS: u32 = 7;
pub const BMA2x2_FLAT_STAT_LEN: u32 = 1;
pub const BMA2x2_FLAT_STAT_MSK: u32 = 128;
pub const BMA2x2_FLAT_STAT_REG: u32 = 12;
pub const BMA2x2_FIFO_FRAME_COUNT_STAT_POS: u32 = 0;
pub const BMA2x2_FIFO_FRAME_COUNT_STAT_LEN: u32 = 7;
pub const BMA2x2_FIFO_FRAME_COUNT_STAT_MSK: u32 = 127;
pub const BMA2x2_FIFO_FRAME_COUNT_STAT_REG: u32 = 14;
pub const BMA2x2_FIFO_OVERRUN_STAT_POS: u32 = 7;
pub const BMA2x2_FIFO_OVERRUN_STAT_LEN: u32 = 1;
pub const BMA2x2_FIFO_OVERRUN_STAT_MSK: u32 = 128;
pub const BMA2x2_FIFO_OVERRUN_STAT_REG: u32 = 14;
pub const BMA2x2_RANGE_SELECT_POS: u32 = 0;
pub const BMA2x2_RANGE_SELECT_LEN: u32 = 4;
pub const BMA2x2_RANGE_SELECT_MSK: u32 = 15;
pub const BMA2x2_RANGE_SELECT_REG: u32 = 15;
pub const BMA2x2_BW_POS: u32 = 0;
pub const BMA2x2_BW_LEN: u32 = 5;
pub const BMA2x2_BW_MSK: u32 = 31;
pub const BMA2x2_BW_REG: u32 = 16;
pub const BMA2x2_SLEEP_DURN_POS: u32 = 1;
pub const BMA2x2_SLEEP_DURN_LEN: u32 = 4;
pub const BMA2x2_SLEEP_DURN_MSK: u32 = 30;
pub const BMA2x2_SLEEP_DURN_REG: u32 = 17;
pub const BMA2x2_MODE_CTRL_POS: u32 = 5;
pub const BMA2x2_MODE_CTRL_LEN: u32 = 3;
pub const BMA2x2_MODE_CTRL_MSK: u32 = 224;
pub const BMA2x2_MODE_CTRL_REG: u32 = 17;
pub const BMA2x2_SLEEP_TIMER_POS: u32 = 5;
pub const BMA2x2_SLEEP_TIMER_LEN: u32 = 1;
pub const BMA2x2_SLEEP_TIMER_MSK: u32 = 32;
pub const BMA2x2_SLEEP_TIMER_REG: u32 = 18;
pub const BMA2x2_LOW_POWER_MODE_POS: u32 = 6;
pub const BMA2x2_LOW_POWER_MODE_LEN: u32 = 1;
pub const BMA2x2_LOW_POWER_MODE_MSK: u32 = 64;
pub const BMA2x2_LOW_POWER_MODE_REG: u32 = 18;
pub const BMA2x2_DIS_SHADOW_PROC_POS: u32 = 6;
pub const BMA2x2_DIS_SHADOW_PROC_LEN: u32 = 1;
pub const BMA2x2_DIS_SHADOW_PROC_MSK: u32 = 64;
pub const BMA2x2_DIS_SHADOW_PROC_REG: u32 = 19;
pub const BMA2x2_ENABLE_DATA_HIGH_BW_POS: u32 = 7;
pub const BMA2x2_ENABLE_DATA_HIGH_BW_LEN: u32 = 1;
pub const BMA2x2_ENABLE_DATA_HIGH_BW_MSK: u32 = 128;
pub const BMA2x2_ENABLE_DATA_HIGH_BW_REG: u32 = 19;
pub const BMA2x2_ENABLE_SOFT_RESET_VALUE: u32 = 182;
pub const BMA2x2_ENABLE_SLOPE_X_INTR_POS: u32 = 0;
pub const BMA2x2_ENABLE_SLOPE_X_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_SLOPE_X_INTR_MSK: u32 = 1;
pub const BMA2x2_ENABLE_SLOPE_X_INTR_REG: u32 = 22;
pub const BMA2x2_ENABLE_SLOPE_Y_INTR_POS: u32 = 1;
pub const BMA2x2_ENABLE_SLOPE_Y_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_SLOPE_Y_INTR_MSK: u32 = 2;
pub const BMA2x2_ENABLE_SLOPE_Y_INTR_REG: u32 = 22;
pub const BMA2x2_ENABLE_SLOPE_Z_INTR_POS: u32 = 2;
pub const BMA2x2_ENABLE_SLOPE_Z_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_SLOPE_Z_INTR_MSK: u32 = 4;
pub const BMA2x2_ENABLE_SLOPE_Z_INTR_REG: u32 = 22;
pub const BMA2x2_ENABLE_DOUBLE_TAP_INTR_POS: u32 = 4;
pub const BMA2x2_ENABLE_DOUBLE_TAP_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_DOUBLE_TAP_INTR_MSK: u32 = 16;
pub const BMA2x2_ENABLE_DOUBLE_TAP_INTR_REG: u32 = 22;
pub const BMA2x2_ENABLE_SINGLE_TAP_INTR_POS: u32 = 5;
pub const BMA2x2_ENABLE_SINGLE_TAP_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_SINGLE_TAP_INTR_MSK: u32 = 32;
pub const BMA2x2_ENABLE_SINGLE_TAP_INTR_REG: u32 = 22;
pub const BMA2x2_ENABLE_ORIENT_INTR_POS: u32 = 6;
pub const BMA2x2_ENABLE_ORIENT_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_ORIENT_INTR_MSK: u32 = 64;
pub const BMA2x2_ENABLE_ORIENT_INTR_REG: u32 = 22;
pub const BMA2x2_ENABLE_FLAT_INTR_POS: u32 = 7;
pub const BMA2x2_ENABLE_FLAT_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_FLAT_INTR_MSK: u32 = 128;
pub const BMA2x2_ENABLE_FLAT_INTR_REG: u32 = 22;
pub const BMA2x2_ENABLE_HIGH_G_X_INTR_POS: u32 = 0;
pub const BMA2x2_ENABLE_HIGH_G_X_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_HIGH_G_X_INTR_MSK: u32 = 1;
pub const BMA2x2_ENABLE_HIGH_G_X_INTR_REG: u32 = 23;
pub const BMA2x2_ENABLE_HIGH_G_Y_INTR_POS: u32 = 1;
pub const BMA2x2_ENABLE_HIGH_G_Y_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_HIGH_G_Y_INTR_MSK: u32 = 2;
pub const BMA2x2_ENABLE_HIGH_G_Y_INTR_REG: u32 = 23;
pub const BMA2x2_ENABLE_HIGH_G_Z_INTR_POS: u32 = 2;
pub const BMA2x2_ENABLE_HIGH_G_Z_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_HIGH_G_Z_INTR_MSK: u32 = 4;
pub const BMA2x2_ENABLE_HIGH_G_Z_INTR_REG: u32 = 23;
pub const BMA2x2_ENABLE_LOW_G_INTR_POS: u32 = 3;
pub const BMA2x2_ENABLE_LOW_G_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_LOW_G_INTR_MSK: u32 = 8;
pub const BMA2x2_ENABLE_LOW_G_INTR_REG: u32 = 23;
pub const BMA2x2_ENABLE_NEW_DATA_INTR_POS: u32 = 4;
pub const BMA2x2_ENABLE_NEW_DATA_INTR_LEN: u32 = 1;
pub const BMA2x2_ENABLE_NEW_DATA_INTR_MSK: u32 = 16;
pub const BMA2x2_ENABLE_NEW_DATA_INTR_REG: u32 = 23;
pub const BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_POS: u32 = 5;
pub const BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_LEN: u32 = 1;
pub const BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_MSK: u32 = 32;
pub const BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_REG: u32 = 23;
pub const BMA2x2_INTR_FIFO_WM_ENABLE_INTR_POS: u32 = 6;
pub const BMA2x2_INTR_FIFO_WM_ENABLE_INTR_LEN: u32 = 1;
pub const BMA2x2_INTR_FIFO_WM_ENABLE_INTR_MSK: u32 = 64;
pub const BMA2x2_INTR_FIFO_WM_ENABLE_INTR_REG: u32 = 23;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_POS: u32 = 0;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_LEN: u32 = 1;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_MSK: u32 = 1;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_REG: u32 = 24;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_POS: u32 = 1;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_LEN: u32 = 1;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_MSK: u32 = 2;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_REG: u32 = 24;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_POS: u32 = 2;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_LEN: u32 = 1;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_MSK: u32 = 4;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_REG: u32 = 24;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_POS: u32 = 3;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_LEN: u32 = 1;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_MSK: u32 = 8;
pub const BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_REG: u32 = 24;
pub const BMA2x2_ENABLE_INTR1_PAD_LOW_G_POS: u32 = 0;
pub const BMA2x2_ENABLE_INTR1_PAD_LOW_G_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_LOW_G_MSK: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_LOW_G_REG: u32 = 25;
pub const BMA2x2_ENABLE_INTR1_PAD_HIGH_G_POS: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_HIGH_G_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_HIGH_G_MSK: u32 = 2;
pub const BMA2x2_ENABLE_INTR1_PAD_HIGH_G_REG: u32 = 25;
pub const BMA2x2_ENABLE_INTR1_PAD_SLOPE_POS: u32 = 2;
pub const BMA2x2_ENABLE_INTR1_PAD_SLOPE_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_SLOPE_MSK: u32 = 4;
pub const BMA2x2_ENABLE_INTR1_PAD_SLOPE_REG: u32 = 25;
pub const BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_POS: u32 = 3;
pub const BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_MSK: u32 = 8;
pub const BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_REG: u32 = 25;
pub const BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_POS: u32 = 4;
pub const BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_MSK: u32 = 16;
pub const BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_REG: u32 = 25;
pub const BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_POS: u32 = 5;
pub const BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_MSK: u32 = 32;
pub const BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_REG: u32 = 25;
pub const BMA2x2_ENABLE_INTR1_PAD_ORIENT_POS: u32 = 6;
pub const BMA2x2_ENABLE_INTR1_PAD_ORIENT_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_ORIENT_MSK: u32 = 64;
pub const BMA2x2_ENABLE_INTR1_PAD_ORIENT_REG: u32 = 25;
pub const BMA2x2_ENABLE_INTR1_PAD_FLAT_POS: u32 = 7;
pub const BMA2x2_ENABLE_INTR1_PAD_FLAT_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_FLAT_MSK: u32 = 128;
pub const BMA2x2_ENABLE_INTR1_PAD_FLAT_REG: u32 = 25;
pub const BMA2x2_ENABLE_INTR2_PAD_LOW_G_POS: u32 = 0;
pub const BMA2x2_ENABLE_INTR2_PAD_LOW_G_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_LOW_G_MSK: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_LOW_G_REG: u32 = 27;
pub const BMA2x2_ENABLE_INTR2_PAD_HIGH_G_POS: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_HIGH_G_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_HIGH_G_MSK: u32 = 2;
pub const BMA2x2_ENABLE_INTR2_PAD_HIGH_G_REG: u32 = 27;
pub const BMA2x2_ENABLE_INTR2_PAD_SLOPE_POS: u32 = 2;
pub const BMA2x2_ENABLE_INTR2_PAD_SLOPE_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_SLOPE_MSK: u32 = 4;
pub const BMA2x2_ENABLE_INTR2_PAD_SLOPE_REG: u32 = 27;
pub const BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_POS: u32 = 3;
pub const BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_MSK: u32 = 8;
pub const BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_REG: u32 = 27;
pub const BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_POS: u32 = 4;
pub const BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_MSK: u32 = 16;
pub const BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_REG: u32 = 27;
pub const BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_POS: u32 = 5;
pub const BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_MSK: u32 = 32;
pub const BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_REG: u32 = 27;
pub const BMA2x2_ENABLE_INTR2_PAD_ORIENT_POS: u32 = 6;
pub const BMA2x2_ENABLE_INTR2_PAD_ORIENT_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_ORIENT_MSK: u32 = 64;
pub const BMA2x2_ENABLE_INTR2_PAD_ORIENT_REG: u32 = 27;
pub const BMA2x2_ENABLE_INTR2_PAD_FLAT_POS: u32 = 7;
pub const BMA2x2_ENABLE_INTR2_PAD_FLAT_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_FLAT_MSK: u32 = 128;
pub const BMA2x2_ENABLE_INTR2_PAD_FLAT_REG: u32 = 27;
pub const BMA2x2_ENABLE_INTR1_PAD_NEWDATA_POS: u32 = 0;
pub const BMA2x2_ENABLE_INTR1_PAD_NEWDATA_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_NEWDATA_MSK: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_NEWDATA_REG: u32 = 26;
pub const BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_POS: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_MSK: u32 = 2;
pub const BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_REG: u32 = 26;
pub const BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_POS: u32 = 2;
pub const BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_MSK: u32 = 4;
pub const BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_REG: u32 = 26;
pub const BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_POS: u32 = 5;
pub const BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_MSK: u32 = 32;
pub const BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_REG: u32 = 26;
pub const BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_POS: u32 = 6;
pub const BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_MSK: u32 = 64;
pub const BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_REG: u32 = 26;
pub const BMA2x2_ENABLE_INTR2_PAD_NEWDATA_POS: u32 = 7;
pub const BMA2x2_ENABLE_INTR2_PAD_NEWDATA_LEN: u32 = 1;
pub const BMA2x2_ENABLE_INTR2_PAD_NEWDATA_MSK: u32 = 128;
pub const BMA2x2_ENABLE_INTR2_PAD_NEWDATA_REG: u32 = 26;
pub const BMA2x2_UNFILT_INTR_SOURCE_LOW_G_POS: u32 = 0;
pub const BMA2x2_UNFILT_INTR_SOURCE_LOW_G_LEN: u32 = 1;
pub const BMA2x2_UNFILT_INTR_SOURCE_LOW_G_MSK: u32 = 1;
pub const BMA2x2_UNFILT_INTR_SOURCE_LOW_G_REG: u32 = 30;
pub const BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_POS: u32 = 1;
pub const BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_LEN: u32 = 1;
pub const BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_MSK: u32 = 2;
pub const BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_REG: u32 = 30;
pub const BMA2x2_UNFILT_INTR_SOURCE_SLOPE_POS: u32 = 2;
pub const BMA2x2_UNFILT_INTR_SOURCE_SLOPE_LEN: u32 = 1;
pub const BMA2x2_UNFILT_INTR_SOURCE_SLOPE_MSK: u32 = 4;
pub const BMA2x2_UNFILT_INTR_SOURCE_SLOPE_REG: u32 = 30;
pub const BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_POS: u32 = 3;
pub const BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_LEN: u32 = 1;
pub const BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_MSK: u32 = 8;
pub const BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_REG: u32 = 30;
pub const BMA2x2_UNFILT_INTR_SOURCE_TAP_POS: u32 = 4;
pub const BMA2x2_UNFILT_INTR_SOURCE_TAP_LEN: u32 = 1;
pub const BMA2x2_UNFILT_INTR_SOURCE_TAP_MSK: u32 = 16;
pub const BMA2x2_UNFILT_INTR_SOURCE_TAP_REG: u32 = 30;
pub const BMA2x2_UNFILT_INTR_SOURCE_DATA_POS: u32 = 5;
pub const BMA2x2_UNFILT_INTR_SOURCE_DATA_LEN: u32 = 1;
pub const BMA2x2_UNFILT_INTR_SOURCE_DATA_MSK: u32 = 32;
pub const BMA2x2_UNFILT_INTR_SOURCE_DATA_REG: u32 = 30;
pub const BMA2x2_INTR1_PAD_ACTIVE_LEVEL_POS: u32 = 0;
pub const BMA2x2_INTR1_PAD_ACTIVE_LEVEL_LEN: u32 = 1;
pub const BMA2x2_INTR1_PAD_ACTIVE_LEVEL_MSK: u32 = 1;
pub const BMA2x2_INTR1_PAD_ACTIVE_LEVEL_REG: u32 = 32;
pub const BMA2x2_INTR2_PAD_ACTIVE_LEVEL_POS: u32 = 2;
pub const BMA2x2_INTR2_PAD_ACTIVE_LEVEL_LEN: u32 = 1;
pub const BMA2x2_INTR2_PAD_ACTIVE_LEVEL_MSK: u32 = 4;
pub const BMA2x2_INTR2_PAD_ACTIVE_LEVEL_REG: u32 = 32;
pub const BMA2x2_INTR1_PAD_OUTPUT_TYPE_POS: u32 = 1;
pub const BMA2x2_INTR1_PAD_OUTPUT_TYPE_LEN: u32 = 1;
pub const BMA2x2_INTR1_PAD_OUTPUT_TYPE_MSK: u32 = 2;
pub const BMA2x2_INTR1_PAD_OUTPUT_TYPE_REG: u32 = 32;
pub const BMA2x2_INTR2_PAD_OUTPUT_TYPE_POS: u32 = 3;
pub const BMA2x2_INTR2_PAD_OUTPUT_TYPE_LEN: u32 = 1;
pub const BMA2x2_INTR2_PAD_OUTPUT_TYPE_MSK: u32 = 8;
pub const BMA2x2_INTR2_PAD_OUTPUT_TYPE_REG: u32 = 32;
pub const BMA2x2_LATCH_INTR_POS: u32 = 0;
pub const BMA2x2_LATCH_INTR_LEN: u32 = 4;
pub const BMA2x2_LATCH_INTR_MSK: u32 = 15;
pub const BMA2x2_LATCH_INTR_REG: u32 = 33;
pub const BMA2x2_RESET_INTR_POS: u32 = 7;
pub const BMA2x2_RESET_INTR_LEN: u32 = 1;
pub const BMA2x2_RESET_INTR_MSK: u32 = 128;
pub const BMA2x2_RESET_INTR_REG: u32 = 33;
pub const BMA2x2_LOW_G_HYST_POS: u32 = 0;
pub const BMA2x2_LOW_G_HYST_LEN: u32 = 2;
pub const BMA2x2_LOW_G_HYST_MSK: u32 = 3;
pub const BMA2x2_LOW_G_HYST_REG: u32 = 36;
pub const BMA2x2_LOW_G_INTR_MODE_POS: u32 = 2;
pub const BMA2x2_LOW_G_INTR_MODE_LEN: u32 = 1;
pub const BMA2x2_LOW_G_INTR_MODE_MSK: u32 = 4;
pub const BMA2x2_LOW_G_INTR_MODE_REG: u32 = 36;
pub const BMA2x2_HIGH_G_HYST_POS: u32 = 6;
pub const BMA2x2_HIGH_G_HYST_LEN: u32 = 2;
pub const BMA2x2_HIGH_G_HYST_MSK: u32 = 192;
pub const BMA2x2_HIGH_G_HYST_REG: u32 = 36;
pub const BMA2x2_SLOPE_DURN_POS: u32 = 0;
pub const BMA2x2_SLOPE_DURN_LEN: u32 = 2;
pub const BMA2x2_SLOPE_DURN_MSK: u32 = 3;
pub const BMA2x2_SLOPE_DURN_REG: u32 = 39;
pub const BMA2x2_SLOW_NO_MOTION_DURN_POS: u32 = 2;
pub const BMA2x2_SLOW_NO_MOTION_DURN_LEN: u32 = 6;
pub const BMA2x2_SLOW_NO_MOTION_DURN_MSK: u32 = 252;
pub const BMA2x2_SLOW_NO_MOTION_DURN_REG: u32 = 39;
pub const BMA2x2_TAP_DURN_POS: u32 = 0;
pub const BMA2x2_TAP_DURN_LEN: u32 = 3;
pub const BMA2x2_TAP_DURN_MSK: u32 = 7;
pub const BMA2x2_TAP_DURN_REG: u32 = 42;
pub const BMA2x2_TAP_SHOCK_DURN_POS: u32 = 6;
pub const BMA2x2_TAP_SHOCK_DURN_LEN: u32 = 1;
pub const BMA2x2_TAP_SHOCK_DURN_MSK: u32 = 64;
pub const BMA2x2_TAP_SHOCK_DURN_REG: u32 = 42;
pub const BMA2x2_ADV_TAP_INTR_POS: u32 = 5;
pub const BMA2x2_ADV_TAP_INTR_LEN: u32 = 1;
pub const BMA2x2_ADV_TAP_INTR_MSK: u32 = 32;
pub const BMA2x2_ADV_TAP_INTR_REG: u32 = 42;
pub const BMA2x2_TAP_QUIET_DURN_POS: u32 = 7;
pub const BMA2x2_TAP_QUIET_DURN_LEN: u32 = 1;
pub const BMA2x2_TAP_QUIET_DURN_MSK: u32 = 128;
pub const BMA2x2_TAP_QUIET_DURN_REG: u32 = 42;
pub const BMA2x2_TAP_THRES_POS: u32 = 0;
pub const BMA2x2_TAP_THRES_LEN: u32 = 5;
pub const BMA2x2_TAP_THRES_MSK: u32 = 31;
pub const BMA2x2_TAP_THRES_REG: u32 = 43;
pub const BMA2x2_TAP_SAMPLES_POS: u32 = 6;
pub const BMA2x2_TAP_SAMPLES_LEN: u32 = 2;
pub const BMA2x2_TAP_SAMPLES_MSK: u32 = 192;
pub const BMA2x2_TAP_SAMPLES_REG: u32 = 43;
pub const BMA2x2_ORIENT_MODE_POS: u32 = 0;
pub const BMA2x2_ORIENT_MODE_LEN: u32 = 2;
pub const BMA2x2_ORIENT_MODE_MSK: u32 = 3;
pub const BMA2x2_ORIENT_MODE_REG: u32 = 44;
pub const BMA2x2_ORIENT_BLOCK_POS: u32 = 2;
pub const BMA2x2_ORIENT_BLOCK_LEN: u32 = 2;
pub const BMA2x2_ORIENT_BLOCK_MSK: u32 = 12;
pub const BMA2x2_ORIENT_BLOCK_REG: u32 = 44;
pub const BMA2x2_ORIENT_HYST_POS: u32 = 4;
pub const BMA2x2_ORIENT_HYST_LEN: u32 = 3;
pub const BMA2x2_ORIENT_HYST_MSK: u32 = 112;
pub const BMA2x2_ORIENT_HYST_REG: u32 = 44;
pub const BMA2x2_ORIENT_UD_ENABLE_POS: u32 = 6;
pub const BMA2x2_ORIENT_UD_ENABLE_LEN: u32 = 1;
pub const BMA2x2_ORIENT_UD_ENABLE_MSK: u32 = 64;
pub const BMA2x2_ORIENT_UD_ENABLE_REG: u32 = 45;
pub const BMA2x2_THETA_BLOCK_POS: u32 = 0;
pub const BMA2x2_THETA_BLOCK_LEN: u32 = 6;
pub const BMA2x2_THETA_BLOCK_MSK: u32 = 63;
pub const BMA2x2_THETA_BLOCK_REG: u32 = 45;
pub const BMA2x2_THETA_FLAT_POS: u32 = 0;
pub const BMA2x2_THETA_FLAT_LEN: u32 = 6;
pub const BMA2x2_THETA_FLAT_MSK: u32 = 63;
pub const BMA2x2_THETA_FLAT_REG: u32 = 46;
pub const BMA2x2_FLAT_HOLD_TIME_POS: u32 = 4;
pub const BMA2x2_FLAT_HOLD_TIME_LEN: u32 = 2;
pub const BMA2x2_FLAT_HOLD_TIME_MSK: u32 = 48;
pub const BMA2x2_FLAT_HOLD_TIME_REG: u32 = 47;
pub const BMA2x2_FLAT_HYST_POS: u32 = 0;
pub const BMA2x2_FLAT_HYST_LEN: u32 = 3;
pub const BMA2x2_FLAT_HYST_MSK: u32 = 7;
pub const BMA2x2_FLAT_HYST_REG: u32 = 47;
pub const BMA2x2_FIFO_WML_TRIG_RETAIN_POS: u32 = 0;
pub const BMA2x2_FIFO_WML_TRIG_RETAIN_LEN: u32 = 6;
pub const BMA2x2_FIFO_WML_TRIG_RETAIN_MSK: u32 = 63;
pub const BMA2x2_FIFO_WML_TRIG_RETAIN_REG: u32 = 48;
pub const BMA2x2_ENABLE_SELFTEST_POS: u32 = 0;
pub const BMA2x2_ENABLE_SELFTEST_LEN: u32 = 2;
pub const BMA2x2_ENABLE_SELFTEST_MSK: u32 = 3;
pub const BMA2x2_ENABLE_SELFTEST_REG: u32 = 50;
pub const BMA2x2_NEG_SELFTEST_POS: u32 = 2;
pub const BMA2x2_NEG_SELFTEST_LEN: u32 = 1;
pub const BMA2x2_NEG_SELFTEST_MSK: u32 = 4;
pub const BMA2x2_NEG_SELFTEST_REG: u32 = 50;
pub const BMA2x2_UNLOCK_EE_PROG_MODE_POS: u32 = 0;
pub const BMA2x2_UNLOCK_EE_PROG_MODE_LEN: u32 = 1;
pub const BMA2x2_UNLOCK_EE_PROG_MODE_MSK: u32 = 1;
pub const BMA2x2_UNLOCK_EE_PROG_MODE_REG: u32 = 51;
pub const BMA2x2_START_EE_PROG_TRIG_POS: u32 = 1;
pub const BMA2x2_START_EE_PROG_TRIG_LEN: u32 = 1;
pub const BMA2x2_START_EE_PROG_TRIG_MSK: u32 = 2;
pub const BMA2x2_START_EE_PROG_TRIG_REG: u32 = 51;
pub const BMA2x2_EE_PROG_READY_POS: u32 = 2;
pub const BMA2x2_EE_PROG_READY_LEN: u32 = 1;
pub const BMA2x2_EE_PROG_READY_MSK: u32 = 4;
pub const BMA2x2_EE_PROG_READY_REG: u32 = 51;
pub const BMA2x2_UPDATE_IMAGE_POS: u32 = 3;
pub const BMA2x2_UPDATE_IMAGE_LEN: u32 = 1;
pub const BMA2x2_UPDATE_IMAGE_MSK: u32 = 8;
pub const BMA2x2_UPDATE_IMAGE_REG: u32 = 51;
pub const BMA2x2_EE_REMAIN_POS: u32 = 4;
pub const BMA2x2_EE_REMAIN_LEN: u32 = 4;
pub const BMA2x2_EE_REMAIN_MSK: u32 = 240;
pub const BMA2x2_EE_REMAIN_REG: u32 = 51;
pub const BMA2x2_ENABLE_SPI_MODE_3_POS: u32 = 0;
pub const BMA2x2_ENABLE_SPI_MODE_3_LEN: u32 = 1;
pub const BMA2x2_ENABLE_SPI_MODE_3_MSK: u32 = 1;
pub const BMA2x2_ENABLE_SPI_MODE_3_REG: u32 = 52;
pub const BMA2x2_I2C_WDT_PERIOD_POS: u32 = 1;
pub const BMA2x2_I2C_WDT_PERIOD_LEN: u32 = 1;
pub const BMA2x2_I2C_WDT_PERIOD_MSK: u32 = 2;
pub const BMA2x2_I2C_WDT_PERIOD_REG: u32 = 52;
pub const BMA2x2_ENABLE_I2C_WDT_POS: u32 = 2;
pub const BMA2x2_ENABLE_I2C_WDT_LEN: u32 = 1;
pub const BMA2x2_ENABLE_I2C_WDT_MSK: u32 = 4;
pub const BMA2x2_ENABLE_I2C_WDT_REG: u32 = 52;
pub const BMA2x2_UNLOCK_EE_WRITE_TRIM_POS: u32 = 4;
pub const BMA2x2_UNLOCK_EE_WRITE_TRIM_LEN: u32 = 4;
pub const BMA2x2_UNLOCK_EE_WRITE_TRIM_MSK: u32 = 240;
pub const BMA2x2_ENABLE_SLOW_COMP_X_POS: u32 = 0;
pub const BMA2x2_ENABLE_SLOW_COMP_X_LEN: u32 = 1;
pub const BMA2x2_ENABLE_SLOW_COMP_X_MSK: u32 = 1;
pub const BMA2x2_ENABLE_SLOW_COMP_X_REG: u32 = 54;
pub const BMA2x2_ENABLE_SLOW_COMP_Y_POS: u32 = 1;
pub const BMA2x2_ENABLE_SLOW_COMP_Y_LEN: u32 = 1;
pub const BMA2x2_ENABLE_SLOW_COMP_Y_MSK: u32 = 2;
pub const BMA2x2_ENABLE_SLOW_COMP_Y_REG: u32 = 54;
pub const BMA2x2_ENABLE_SLOW_COMP_Z_POS: u32 = 2;
pub const BMA2x2_ENABLE_SLOW_COMP_Z_LEN: u32 = 1;
pub const BMA2x2_ENABLE_SLOW_COMP_Z_MSK: u32 = 4;
pub const BMA2x2_ENABLE_SLOW_COMP_Z_REG: u32 = 54;
pub const BMA2x2_FAST_CAL_RDY_STAT_POS: u32 = 4;
pub const BMA2x2_FAST_CAL_RDY_STAT_LEN: u32 = 1;
pub const BMA2x2_FAST_CAL_RDY_STAT_MSK: u32 = 16;
pub const BMA2x2_FAST_CAL_RDY_STAT_REG: u32 = 54;
pub const BMA2x2_CAL_TRIGGER_POS: u32 = 5;
pub const BMA2x2_CAL_TRIGGER_LEN: u32 = 2;
pub const BMA2x2_CAL_TRIGGER_MSK: u32 = 96;
pub const BMA2x2_CAL_TRIGGER_REG: u32 = 54;
pub const BMA2x2_RST_OFFSET_POS: u32 = 7;
pub const BMA2x2_RST_OFFSET_LEN: u32 = 1;
pub const BMA2x2_RST_OFFSET_MSK: u32 = 128;
pub const BMA2x2_RST_OFFSET_REG: u32 = 54;
pub const BMA2x2_COMP_CUTOFF_POS: u32 = 0;
pub const BMA2x2_COMP_CUTOFF_LEN: u32 = 1;
pub const BMA2x2_COMP_CUTOFF_MSK: u32 = 1;
pub const BMA2x2_COMP_CUTOFF_REG: u32 = 55;
pub const BMA2x2_COMP_TARGET_OFFSET_X_POS: u32 = 1;
pub const BMA2x2_COMP_TARGET_OFFSET_X_LEN: u32 = 2;
pub const BMA2x2_COMP_TARGET_OFFSET_X_MSK: u32 = 6;
pub const BMA2x2_COMP_TARGET_OFFSET_X_REG: u32 = 55;
pub const BMA2x2_COMP_TARGET_OFFSET_Y_POS: u32 = 3;
pub const BMA2x2_COMP_TARGET_OFFSET_Y_LEN: u32 = 2;
pub const BMA2x2_COMP_TARGET_OFFSET_Y_MSK: u32 = 24;
pub const BMA2x2_COMP_TARGET_OFFSET_Y_REG: u32 = 55;
pub const BMA2x2_COMP_TARGET_OFFSET_Z_POS: u32 = 5;
pub const BMA2x2_COMP_TARGET_OFFSET_Z_LEN: u32 = 2;
pub const BMA2x2_COMP_TARGET_OFFSET_Z_MSK: u32 = 96;
pub const BMA2x2_COMP_TARGET_OFFSET_Z_REG: u32 = 55;
pub const BMA2x2_FIFO_DATA_SELECT_POS: u32 = 0;
pub const BMA2x2_FIFO_DATA_SELECT_LEN: u32 = 2;
pub const BMA2x2_FIFO_DATA_SELECT_MSK: u32 = 3;
pub const BMA2x2_FIFO_DATA_SELECT_REG: u32 = 62;
pub const BMA2x2_FIFO_MODE_POS: u32 = 6;
pub const BMA2x2_FIFO_MODE_LEN: u32 = 2;
pub const BMA2x2_FIFO_MODE_MSK: u32 = 192;
pub const BMA2x2_FIFO_MODE_REG: u32 = 62;
pub const BMA2x2_14_BIT_SHIFT: u32 = 252;
pub const BMA2x2_10_BIT_SHIFT: u32 = 192;
pub const BMA2x2_12_BIT_SHIFT: u32 = 240;
pub const BANDWIDTH_DEFINE: u32 = 251;
pub const INTR_ENABLE: u32 = 1;
pub const INTR_DISABLE: u32 = 0;
pub const OPEN_DRAIN: u32 = 1;
pub const PUSS_PULL: u32 = 1;
pub const ACTIVE_LOW: u32 = 0;
pub const ACTIVE_HIGH: u32 = 1;
pub const BMA2x2_STAT1: u32 = 0;
pub const BMA2x2_STAT2: u32 = 1;
pub const BMA2x2_STAT3: u32 = 2;
pub const BMA2x2_STAT4: u32 = 3;
pub const BMA2x2_STAT5: u32 = 4;
pub const BMA2x2_RANGE_2G: u32 = 3;
pub const BMA2x2_RANGE_4G: u32 = 5;
pub const BMA2x2_RANGE_8G: u32 = 8;
pub const BMA2x2_RANGE_16G: u32 = 12;
pub const BMA2x2_BW_7_81HZ: u32 = 8;
pub const BMA2x2_BW_15_63HZ: u32 = 9;
pub const BMA2x2_BW_31_25HZ: u32 = 10;
pub const BMA2x2_BW_62_50HZ: u32 = 11;
pub const BMA2x2_BW_125HZ: u32 = 12;
pub const BMA2x2_BW_250HZ: u32 = 13;
pub const BMA2x2_BW_500HZ: u32 = 14;
pub const BMA2x2_BW_1000HZ: u32 = 15;
pub const BMA2x2_SLEEP_DURN_0_5MS: u32 = 5;
pub const BMA2x2_SLEEP_DURN_1MS: u32 = 6;
pub const BMA2x2_SLEEP_DURN_2MS: u32 = 7;
pub const BMA2x2_SLEEP_DURN_4MS: u32 = 8;
pub const BMA2x2_SLEEP_DURN_6MS: u32 = 9;
pub const BMA2x2_SLEEP_DURN_10MS: u32 = 10;
pub const BMA2x2_SLEEP_DURN_25MS: u32 = 11;
pub const BMA2x2_SLEEP_DURN_50MS: u32 = 12;
pub const BMA2x2_SLEEP_DURN_100MS: u32 = 13;
pub const BMA2x2_SLEEP_DURN_500MS: u32 = 14;
pub const BMA2x2_SLEEP_DURN_1S: u32 = 15;
pub const BMA2x2_LATCH_DURN_NON_LATCH: u32 = 0;
pub const BMA2x2_LATCH_DURN_250MS: u32 = 1;
pub const BMA2x2_LATCH_DURN_500MS: u32 = 2;
pub const BMA2x2_LATCH_DURN_1S: u32 = 3;
pub const BMA2x2_LATCH_DURN_2S: u32 = 4;
pub const BMA2x2_LATCH_DURN_4S: u32 = 5;
pub const BMA2x2_LATCH_DURN_8S: u32 = 6;
pub const BMA2x2_LATCH_DURN_LATCH: u32 = 7;
pub const BMA2x2_LATCH_DURN_NON_LATCH1: u32 = 8;
pub const BMA2x2_LATCH_DURN_250US: u32 = 9;
pub const BMA2x2_LATCH_DURN_500US: u32 = 10;
pub const BMA2x2_LATCH_DURN_1MS: u32 = 11;
pub const BMA2x2_LATCH_DURN_12_5MS: u32 = 12;
pub const BMA2x2_LATCH_DURN_25MS: u32 = 13;
pub const BMA2x2_LATCH_DURN_50MS: u32 = 14;
pub const BMA2x2_LATCH_DURN_LATCH1: u32 = 15;
pub const BMA2x2_MODE_NORMAL: u32 = 0;
pub const BMA2x2_MODE_LOWPOWER1: u32 = 1;
pub const BMA2x2_MODE_SUSPEND: u32 = 2;
pub const BMA2x2_MODE_DEEP_SUSPEND: u32 = 3;
pub const BMA2x2_MODE_LOWPOWER2: u32 = 4;
pub const BMA2x2_MODE_STANDBY: u32 = 5;
pub const BMA2x2_X_AXIS: u32 = 0;
pub const BMA2x2_Y_AXIS: u32 = 1;
pub const BMA2x2_Z_AXIS: u32 = 2;
pub const BMA2x2_LOW_G_INTR: u32 = 0;
pub const BMA2x2_HIGH_G_X_INTR: u32 = 1;
pub const BMA2x2_HIGH_G_Y_INTR: u32 = 2;
pub const BMA2x2_HIGH_G_Z_INTR: u32 = 3;
pub const BMA2x2_DATA_ENABLE: u32 = 4;
pub const BMA2x2_SLOPE_X_INTR: u32 = 5;
pub const BMA2x2_SLOPE_Y_INTR: u32 = 6;
pub const BMA2x2_SLOPE_Z_INTR: u32 = 7;
pub const BMA2x2_SINGLE_TAP_INTR: u32 = 8;
pub const BMA2x2_DOUBLE_TAP_INTR: u32 = 9;
pub const BMA2x2_ORIENT_INTR: u32 = 10;
pub const BMA2x2_FLAT_INTR: u32 = 11;
pub const BMA2x2_FIFO_FULL_INTR: u32 = 12;
pub const BMA2x2_FIFO_WM_INTR: u32 = 13;
pub const BMA2x2_INTR1_LOW_G: u32 = 0;
pub const BMA2x2_INTR2_LOW_G: u32 = 1;
pub const BMA2x2_INTR1_HIGH_G: u32 = 0;
pub const BMA2x2_INTR2_HIGH_G: u32 = 1;
pub const BMA2x2_INTR1_SLOPE: u32 = 0;
pub const BMA2x2_INTR2_SLOPE: u32 = 1;
pub const BMA2x2_INTR1_SLOW_NO_MOTION: u32 = 0;
pub const BMA2x2_INTR2_SLOW_NO_MOTION: u32 = 1;
pub const BMA2x2_INTR1_DOUBLE_TAP: u32 = 0;
pub const BMA2x2_INTR2_DOUBLE_TAP: u32 = 1;
pub const BMA2x2_INTR1_SINGLE_TAP: u32 = 0;
pub const BMA2x2_INTR2_SINGLE_TAP: u32 = 1;
pub const BMA2x2_INTR1_ORIENT: u32 = 0;
pub const BMA2x2_INTR2_ORIENT: u32 = 1;
pub const BMA2x2_INTR1_FLAT: u32 = 0;
pub const BMA2x2_INTR2_FLAT: u32 = 1;
pub const BMA2x2_INTR1_NEWDATA: u32 = 0;
pub const BMA2x2_INTR2_NEWDATA: u32 = 1;
pub const BMA2x2_INTR1_FIFO_WM: u32 = 0;
pub const BMA2x2_INTR2_FIFO_WM: u32 = 1;
pub const BMA2x2_INTR1_FIFO_FULL: u32 = 0;
pub const BMA2x2_INTR2_FIFO_FULL: u32 = 1;
pub const BMA2x2_SOURCE_LOW_G: u32 = 0;
pub const BMA2x2_SOURCE_HIGH_G: u32 = 1;
pub const BMA2x2_SOURCE_SLOPE: u32 = 2;
pub const BMA2x2_SOURCE_SLOW_NO_MOTION: u32 = 3;
pub const BMA2x2_SOURCE_TAP: u32 = 4;
pub const BMA2x2_SOURCE_DATA: u32 = 5;
pub const BMA2x2_INTR1_OUTPUT: u32 = 0;
pub const BMA2x2_INTR2_OUTPUT: u32 = 1;
pub const BMA2x2_INTR1_LEVEL: u32 = 0;
pub const BMA2x2_INTR2_LEVEL: u32 = 1;
pub const BMA2x2_LOW_DURN: u32 = 0;
pub const BMA2x2_HIGH_DURN: u32 = 1;
pub const BMA2x2_SLOPE_DURN: u32 = 2;
pub const BMA2x2_SLOW_NO_MOTION_DURN: u32 = 3;
pub const BMA2x2_LOW_THRES: u32 = 0;
pub const BMA2x2_HIGH_THRES: u32 = 1;
pub const BMA2x2_SLOPE_THRES: u32 = 2;
pub const BMA2x2_SLOW_NO_MOTION_THRES: u32 = 3;
pub const BMA2x2_LOW_G_HYST: u32 = 0;
pub const BMA2x2_HIGH_G_HYST: u32 = 1;
pub const BMA2x2_ORIENT_THETA: u32 = 0;
pub const BMA2x2_FLAT_THETA: u32 = 1;
pub const BMA2x2_I2C_SELECT: u32 = 0;
pub const BMA2x2_I2C_ENABLE: u32 = 1;
pub const BMA2x2_SLOW_COMP_X: u32 = 0;
pub const BMA2x2_SLOW_COMP_Y: u32 = 1;
pub const BMA2x2_SLOW_COMP_Z: u32 = 2;
pub const BMA2x2_CUT_OFF: u32 = 0;
pub const BMA2x2_OFFSET_TRIGGER_X: u32 = 1;
pub const BMA2x2_OFFSET_TRIGGER_Y: u32 = 2;
pub const BMA2x2_OFFSET_TRIGGER_Z: u32 = 3;
pub const BMA2x2_GP0: u32 = 0;
pub const BMA2x2_GP1: u32 = 1;
pub const BMA2x2_SLOW_NO_MOTION_ENABLE_X: u32 = 0;
pub const BMA2x2_SLOW_NO_MOTION_ENABLE_Y: u32 = 1;
pub const BMA2x2_SLOW_NO_MOTION_ENABLE_Z: u32 = 2;
pub const BMA2x2_SLOW_NO_MOTION_ENABLE_SELECT: u32 = 3;
pub const BMA2x2_WAKE_UP_DURN_20MS: u32 = 0;
pub const BMA2x2_WAKE_UP_DURN_80MS: u32 = 1;
pub const BMA2x2_WAKE_UP_DURN_320MS: u32 = 2;
pub const BMA2x2_WAKE_UP_DURN_2560MS: u32 = 3;
pub const BMA2x2_SELFTEST0_ON: u32 = 1;
pub const BMA2x2_SELFTEST1_ON: u32 = 2;
pub const BMA2x2_EE_W_OFF: u32 = 0;
pub const BMA2x2_EE_W_ON: u32 = 1;
pub const BMA2x2_RESOLUTION_12_BIT: u32 = 0;
pub const BMA2x2_RESOLUTION_10_BIT: u32 = 1;
pub const BMA2x2_RESOLUTION_14_BIT: u32 = 3;
pub const BMA2x2: u32 = 22;
pub const BMA280: u32 = 23;
pub const BMA222E: u32 = 24;
pub const BMA250E: u32 = 25;
pub const LOW_G_SINGLE_AXIS_MODE: u32 = 0;
pub const LOW_G_SUMMING_MODE: u32 = 1;
pub const TAP_DURN_50_MS: u32 = 0;
pub const TAP_DURN_100_MS: u32 = 1;
pub const TAP_DURN_150_MS: u32 = 2;
pub const TAP_DURN_200_MS: u32 = 3;
pub const TAP_DURN_250_MS: u32 = 4;
pub const TAP_DURN_375_MS: u32 = 5;
pub const TAP_DURN_500_MS: u32 = 6;
pub const TAP_DURN_700_MS: u32 = 7;
pub const TAP_SHOCK_50_MS: u32 = 0;
pub const TAP_SHOCK_75_MS: u32 = 1;
pub const TAP_QUIET_30_MS: u32 = 0;
pub const TAP_QUIET_20_MS: u32 = 1;
pub const BMA2x2_ACCEL_DATA_SIZE: u32 = 2;
pub const BMA2x2_ACCEL_XYZ_DATA_SIZE: u32 = 6;
pub const BMA2x2_ACCEL_XYZ_TEMP_DATA_SIZE: u32 = 7;
pub const BMA2x2_SENSOR_DATA_ACCEL_LSB: u32 = 0;
pub const BMA2x2_SENSOR_DATA_ACCEL_MSB: u32 = 1;
pub const BMA2x2_SENSOR_DATA_XYZ_X_LSB: u32 = 0;
pub const BMA2x2_SENSOR_DATA_XYZ_X_MSB: u32 = 1;
pub const BMA2x2_SENSOR_DATA_XYZ_Y_LSB: u32 = 2;
pub const BMA2x2_SENSOR_DATA_XYZ_Y_MSB: u32 = 3;
pub const BMA2x2_SENSOR_DATA_XYZ_Z_LSB: u32 = 4;
pub const BMA2x2_SENSOR_DATA_XYZ_Z_MSB: u32 = 5;
pub const BMA2x2_SENSOR_DATA_TEMP: u32 = 6;
pub const BMA2x2_RESOLUTION_12_MASK: u32 = 240;
pub const BMA2x2_RESOLUTION_10_MASK: u32 = 192;
pub const BMA2x2_RESOLUTION_14_MASK: u32 = 252;
pub const BMA2x2_POWER_MODE_HEX_E_ZERO_MASK: u32 = 224;
pub const BMA2x2_POWER_MODE_HEX_4_ZERO_MASK: u32 = 64;
pub const BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK: u32 = 0;
pub const BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK: u32 = 1;
pub const BMA2x2_POWER_MODE_HEX_ZERO_TWO_MASK: u32 = 2;
pub const BMA2x2_POWER_MODE_HEX_ZERO_FOUR_MASK: u32 = 4;
pub const BMA2x2_POWER_MODE_HEX_ZERO_SIX_MASK: u32 = 6;
pub type s8 = cty::c_schar;
pub type s16 = cty::c_short;
pub type s32 = cty::c_int;
pub type s64 = cty::c_longlong;
pub type u8 = cty::c_uchar;
pub type u16 = cty::c_ushort;
pub type u32 = cty::c_uint;
pub type u64 = cty::c_ulonglong;
#[doc = "\t@brief read accel xyz data for 10,14 and 12 bit resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bma2x2_accel_data {
    #[doc = "< accel x data 10,14 and 12 resolution"]
    pub x: s16,
    #[doc = "< accel y data 10,14 and 12 resolution"]
    pub y: s16,
    #[doc = "< accel z data 10,14 and 12 resolution"]
    pub z: s16,
}
#[test]
fn bindgen_test_layout_bma2x2_accel_data() {
    assert_eq!(
        ::core::mem::size_of::<bma2x2_accel_data>(),
        6usize,
        concat!("Size of: ", stringify!(bma2x2_accel_data))
    );
    assert_eq!(
        ::core::mem::align_of::<bma2x2_accel_data>(),
        2usize,
        concat!("Alignment of ", stringify!(bma2x2_accel_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_accel_data>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_data),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_accel_data>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_data),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_accel_data>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_data),
            "::",
            stringify!(z)
        )
    );
}
#[doc = "\t@brief read accel xyz data for 10,14 and 12 bit resolution"]
#[doc = "\tand temperature output"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bma2x2_accel_data_temp {
    #[doc = "< accel x data 10,14 and 12 resolution"]
    pub x: s16,
    #[doc = "< accel y data 10,14 and 12 resolution"]
    pub y: s16,
    #[doc = "< accel z data 10,14 and 12 resolution"]
    pub z: s16,
    #[doc = "< accel temperature data"]
    pub temp: s8,
}
#[test]
fn bindgen_test_layout_bma2x2_accel_data_temp() {
    assert_eq!(
        ::core::mem::size_of::<bma2x2_accel_data_temp>(),
        8usize,
        concat!("Size of: ", stringify!(bma2x2_accel_data_temp))
    );
    assert_eq!(
        ::core::mem::align_of::<bma2x2_accel_data_temp>(),
        2usize,
        concat!("Alignment of ", stringify!(bma2x2_accel_data_temp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_accel_data_temp>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_data_temp),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_accel_data_temp>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_data_temp),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_accel_data_temp>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_data_temp),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_accel_data_temp>())).temp as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_data_temp),
            "::",
            stringify!(temp)
        )
    );
}
#[doc = "\t@brief read accel xyz data for 8 bit resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bma2x2_accel_eight_resolution {
    #[doc = "< accel x data with eight bit resolution"]
    pub x: s8,
    #[doc = "< accel y data with eight bit resolution"]
    pub y: s8,
    #[doc = "< accel z data with eight bit resolution"]
    pub z: s8,
}
#[test]
fn bindgen_test_layout_bma2x2_accel_eight_resolution() {
    assert_eq!(
        ::core::mem::size_of::<bma2x2_accel_eight_resolution>(),
        3usize,
        concat!("Size of: ", stringify!(bma2x2_accel_eight_resolution))
    );
    assert_eq!(
        ::core::mem::align_of::<bma2x2_accel_eight_resolution>(),
        1usize,
        concat!("Alignment of ", stringify!(bma2x2_accel_eight_resolution))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bma2x2_accel_eight_resolution>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_eight_resolution),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bma2x2_accel_eight_resolution>())).y as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_eight_resolution),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bma2x2_accel_eight_resolution>())).z as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_eight_resolution),
            "::",
            stringify!(z)
        )
    );
}
#[doc = "\t@brief read accel xyz data for 8 bit resolution and temperature"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bma2x2_accel_eight_resolution_temp {
    #[doc = "< accel x data with eight bit resolution"]
    pub x: s8,
    #[doc = "< accel y data with eight bit resolution"]
    pub y: s8,
    #[doc = "< accel z data with eight bit resolution"]
    pub z: s8,
    #[doc = "< accel temperature data"]
    pub temp: s8,
}
#[test]
fn bindgen_test_layout_bma2x2_accel_eight_resolution_temp() {
    assert_eq!(
        ::core::mem::size_of::<bma2x2_accel_eight_resolution_temp>(),
        4usize,
        concat!("Size of: ", stringify!(bma2x2_accel_eight_resolution_temp))
    );
    assert_eq!(
        ::core::mem::align_of::<bma2x2_accel_eight_resolution_temp>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(bma2x2_accel_eight_resolution_temp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bma2x2_accel_eight_resolution_temp>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_eight_resolution_temp),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bma2x2_accel_eight_resolution_temp>())).y as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_eight_resolution_temp),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bma2x2_accel_eight_resolution_temp>())).z as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_eight_resolution_temp),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bma2x2_accel_eight_resolution_temp>())).temp as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_accel_eight_resolution_temp),
            "::",
            stringify!(temp)
        )
    );
}
#[doc = "  @brief FIFO data read is parsed and returned to user using this union."]
#[doc = ""]
#[doc = "  @note Read the respective data fields in the union for corresponding"]
#[doc = "  accel data axes enabled in FIFO storage( Axes stored in FIFO can be set"]
#[doc = "  by the data_select_bits in the register FIFO_CONFIG_1 )"]
#[doc = ""]
#[doc = "  data enabled for FIFO storage | Data field to be read from the below union"]
#[doc = "  ------------------------------|-------------------------------------------"]
#[doc = "          XYZ axes enabled      |         struct bma2x2_accel_data"]
#[doc = "          X axis data enabled   |         x data"]
#[doc = "          Y axis data enabled   |         y data"]
#[doc = "          Z axis data enabled   |         z data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union fifo_frame {
    #[doc = " FIFO data stored here when XYZ data enabled in"]
    #[doc = "fifo_data_select bits of register 0x3E"]
    pub accel_data: bma2x2_accel_data,
    #[doc = " FIFO data stored here when accel X data enabled in"]
    #[doc = "fifo_data_select bits of register 0x3E"]
    pub x: s16,
    #[doc = " FIFO data stored here when accel Y data enabled in"]
    #[doc = "fifo_data_select bits of register 0x3E"]
    pub y: s16,
    #[doc = " FIFO data stored here when accel Z data enabled in"]
    #[doc = "fifo_data_select bits of register 0x3E"]
    pub z: s16,
    _bindgen_union_align: [u16; 3usize],
}
#[test]
fn bindgen_test_layout_fifo_frame() {
    assert_eq!(
        ::core::mem::size_of::<fifo_frame>(),
        6usize,
        concat!("Size of: ", stringify!(fifo_frame))
    );
    assert_eq!(
        ::core::mem::align_of::<fifo_frame>(),
        2usize,
        concat!("Alignment of ", stringify!(fifo_frame))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fifo_frame>())).accel_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_frame),
            "::",
            stringify!(accel_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fifo_frame>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_frame),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fifo_frame>())).y as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_frame),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fifo_frame>())).z as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_frame),
            "::",
            stringify!(z)
        )
    );
}
#[doc = "\t@brief bma2x2 initialization struct"]
#[doc = "\tstruct bma2x2_t is used for assigning the following parameters."]
#[doc = ""]
#[doc = "\tBus write function pointer: BMA2x2_WR_FUNC_PTR"]
#[doc = "\tBus read function pointer: BMA2x2_RD_FUNC_PTR"]
#[doc = "\tBurst read function pointer: BMA2x2_BRD_FUNC_PTR"]
#[doc = "\tDelay function pointer: delay_msec"]
#[doc = "\tI2C address: dev_addr"]
#[doc = "\tChip id of the sensor: chip_id"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bma2x2_t {
    #[doc = " save current bma2x2 operation mode"]
    pub power_mode_u8: u8,
    #[doc = " chip_id of bma2x2"]
    pub chip_id: u8,
    #[doc = " the value of power mode register 0x11"]
    pub ctrl_mode_reg: u8,
    #[doc = " the value of power mode register 0x12"]
    pub low_mode_reg: u8,
    #[doc = " initializes bma2x2's I2C device address"]
    pub dev_addr: u8,
    #[doc = " store the fifo configuration register"]
    pub fifo_config: u8,
    pub bus_write: ::core::option::Option<
        unsafe extern "C" fn(arg1: u8, arg2: u8, arg3: *mut u8, arg4: u8) -> s8,
    >,
    pub bus_read: ::core::option::Option<
        unsafe extern "C" fn(arg1: u8, arg2: u8, arg3: *mut u8, arg4: u8) -> s8,
    >,
    pub burst_read: ::core::option::Option<
        unsafe extern "C" fn(arg1: u8, arg2: u8, arg3: *mut u8, arg4: u32) -> s8,
    >,
    #[doc = " delay(in ms) function pointer"]
    pub delay_msec: ::core::option::Option<unsafe extern "C" fn(arg1: u32)>,
}
#[test]
fn bindgen_test_layout_bma2x2_t() {
    assert_eq!(
        ::core::mem::size_of::<bma2x2_t>(),
        40usize,
        concat!("Size of: ", stringify!(bma2x2_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bma2x2_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bma2x2_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).power_mode_u8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(power_mode_u8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).chip_id as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(chip_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).ctrl_mode_reg as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(ctrl_mode_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).low_mode_reg as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(low_mode_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).dev_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(dev_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).fifo_config as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(fifo_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).bus_write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(bus_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).bus_read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(bus_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).burst_read as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(burst_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bma2x2_t>())).delay_msec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bma2x2_t),
            "::",
            stringify!(delay_msec)
        )
    );
}
#[doc = "  @brief FIFO configurations are stored in this structure"]
#[doc = ""]
#[doc = "  @note User should map the following before reading the FIFO data"]
#[doc = "    - buffer for storing the FIFO data should be mapped to the member"]
#[doc = "     \"fifo_data\" of this structure"]
#[doc = "    - Number of bytes to be read from the FIFO should be mapped to the member"]
#[doc = "     \"fifo_length\" of this structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fifo_configuration {
    #[doc = " Data buffer of user defined length is to be mapped here"]
    pub fifo_data: *mut u8,
    #[doc = " Index of accel data stored in FIFO buffer"]
    pub accel_byte_start_index: u8,
    #[doc = " No of bytes to be read in FIFO as specified by the user"]
    pub fifo_length: u8,
}
#[test]
fn bindgen_test_layout_fifo_configuration() {
    assert_eq!(
        ::core::mem::size_of::<fifo_configuration>(),
        16usize,
        concat!("Size of: ", stringify!(fifo_configuration))
    );
    assert_eq!(
        ::core::mem::align_of::<fifo_configuration>(),
        8usize,
        concat!("Alignment of ", stringify!(fifo_configuration))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fifo_configuration>())).fifo_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_configuration),
            "::",
            stringify!(fifo_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fifo_configuration>())).accel_byte_start_index as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_configuration),
            "::",
            stringify!(accel_byte_start_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fifo_configuration>())).fifo_length as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_configuration),
            "::",
            stringify!(fifo_length)
        )
    );
}
extern "C" {
    #[doc = " @brief"]
    #[doc = "\tThis API reads the data from"]
    #[doc = "\tthe given register continuously"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param addr_u8 -> Address of the register"]
    #[doc = "\t@param data_u8 -> The data from the register"]
    #[doc = "\t@param len_u32 -> no of bytes to read"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_burst_read(addr_u8: u8, data_u8: *mut u8, len_u32: u32) -> s8;
}
extern "C" {
    #[doc = "\t@brief"]
    #[doc = "\tThis function is used for initialize"]
    #[doc = "\tbus read and bus write functions"]
    #[doc = "\tassign the chip id and device address"]
    #[doc = "\tchip id is read in the register 0x00 bit from 0 to 7"]
    #[doc = ""]
    #[doc = "\t@param bma2x2 : structure pointer"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = "\t@note"]
    #[doc = "\tWhile changing the parameter of the bma2x2_t"]
    #[doc = "\tconsider the following point:"]
    #[doc = "\tChanging the reference value of the parameter"]
    #[doc = "\twill changes the local copy or local reference"]
    #[doc = "\tmake sure your changes will not"]
    #[doc = "\taffect the reference value of the parameter"]
    #[doc = "\t(Better case don't change the reference value of the parameter)"]
    pub fn bma2x2_init(bma2x2: *mut bma2x2_t) -> s8;
}
extern "C" {
    #[doc = " @brief"]
    #[doc = "\tThis API gives data to the given register and"]
    #[doc = "\tthe data is written in the corresponding register address"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param adr_u8  -> Address of the register"]
    #[doc = "\t@param data_u8 -> The data to the register"]
    #[doc = "\t@param len_u8 -> no of bytes to read"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_write_reg(adr_u8: u8, data_u8: *mut u8, len_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API reads the data from"]
    #[doc = "           the given register address"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param adr_u8 -> Address of the register"]
    #[doc = "\t@param data_u8 -> The data from the register"]
    #[doc = "\t@param len_u8 -> no of bytes to read"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_reg(adr_u8: u8, data_u8: *mut u8, len_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief"]
    #[doc = "\tThis API reads acceleration data X values"]
    #[doc = "\tfrom location 02h and 03h"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param   accel_x_s16 : pointer holding the data of accel X"]
    #[doc = "\t\t       value       |   resolution"]
    #[doc = "       ----------------- | --------------"]
    #[doc = "              0          | BMA2x2_12_RESOLUTION"]
    #[doc = "              1          | BMA2x2_10_RESOLUTION"]
    #[doc = "              2          | BMA2x2_14_RESOLUTION"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_read_accel_x(accel_x_s16: *mut s16) -> s8;
}
extern "C" {
    #[doc = " @brief"]
    #[doc = "\tThis API reads acceleration data X values"]
    #[doc = "\tfrom location 02h and 03h bit resolution support 8bit"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param   accel_x_s8 : pointer holding the data of accel X"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_read_accel_eight_resolution_x(accel_x_s8: *mut s8) -> s8;
}
extern "C" {
    #[doc = " @brief"]
    #[doc = "\tThis API reads acceleration data Y values"]
    #[doc = "\tfrom location 04h and 05h"]
    #[doc = ""]
    #[doc = "  @param   accel_y_s16 : pointer holding the data of accel Y"]
    #[doc = "\t\t       value       |   resolution"]
    #[doc = "       ----------------- | --------------"]
    #[doc = "              0          | BMA2x2_12_RESOLUTION"]
    #[doc = "              1          | BMA2x2_10_RESOLUTION"]
    #[doc = "              2          | BMA2x2_14_RESOLUTION"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_accel_y(accel_y_s16: *mut s16) -> s8;
}
extern "C" {
    #[doc = " @brief This API reads acceleration data Y values of"]
    #[doc = " 8bit  resolution  from location 05h"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param accel_y_s8   The data of y"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_accel_eight_resolution_y(accel_y_s8: *mut s8) -> s8;
}
extern "C" {
    #[doc = " @brief This API reads acceleration data Z values"]
    #[doc = "                          from location 06h and 07h"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param   accel_z_s16 : pointer holding the data of accel Z"]
    #[doc = "\t\t       value       |   resolution"]
    #[doc = "       ----------------- | --------------"]
    #[doc = "              0          | BMA2x2_12_RESOLUTION"]
    #[doc = "              1          | BMA2x2_10_RESOLUTION"]
    #[doc = "              2          | BMA2x2_14_RESOLUTION"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_accel_z(accel_z_s16: *mut s16) -> s8;
}
extern "C" {
    #[doc = " @brief"]
    #[doc = "\tThis API reads acceleration data Z values of"]
    #[doc = "\t8bit  resolution  from location 07h"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  \\@aram  accel_z_s8 : the data of z"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_accel_eight_resolution_z(accel_z_s8: *mut s8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API reads acceleration data X,Y,Z values"]
    #[doc = "\tfrom location 02h to 07h"]
    #[doc = ""]
    #[doc = "  @param accel : pointer holding the data of accel"]
    #[doc = "\t\t       value       |   resolution"]
    #[doc = "       ----------------- | --------------"]
    #[doc = "              0          | BMA2x2_12_RESOLUTION"]
    #[doc = "              1          | BMA2x2_10_RESOLUTION"]
    #[doc = "              2          | BMA2x2_14_RESOLUTION"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_accel_xyz(accel: *mut bma2x2_accel_data) -> s8;
}
extern "C" {
    #[doc = " @brief This API reads acceleration of 8 bit resolution"]
    #[doc = " data of X,Y,Z values"]
    #[doc = " from location 03h , 05h and 07h"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param accel : pointer holding the data of accel"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_accel_eight_resolution_xyz(accel: *mut bma2x2_accel_eight_resolution) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API read tap-sign, tap-first-xyz"]
    #[doc = "\tslope-sign, slope-first-xyz status register byte"]
    #[doc = "\tfrom location 0Bh"]
    #[doc = ""]
    #[doc = "   @param stat_tap_u8 : The status of tap and slope"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_intr_tap_stat(stat_tap_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API read orient, high-sign and high-first-xyz"]
    #[doc = "\tstatus register byte from location 0Ch"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param stat_orient_u8 : The status of orient and high"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_orient_stat(stat_orient_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API reads fifo overrun and fifo frame counter"]
    #[doc = "\tstatus register byte  from location 0Eh"]
    #[doc = ""]
    #[doc = "  @param stat_fifo_u8 : The status of fifo overrun and frame counter"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_fifo_stat(stat_fifo_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API read fifo frame count"]
    #[doc = "\tfrom location 0Eh bit position 0 to 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param frame_count_u8 : The status of fifo frame count"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_fifo_frame_count(frame_count_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API read fifo overrun"]
    #[doc = "\tfrom location 0Eh bit position 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param fifo_overrun_u8 : The status of fifo overrun"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_fifo_overrun(fifo_overrun_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API read interrupt status of flat, orient, single tap,"]
    #[doc = "\tdouble tap, slow no motion, slope, highg and lowg from location 09h"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param  intr_stat_u8 : The value of interrupt status"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_intr_stat(intr_stat_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get the ranges(g values) of the sensor"]
    #[doc = "\tin the register 0x0F bit from 0 to 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param range_u8 : The value of range"]
    #[doc = "\t\t  range_u8       |   result"]
    #[doc = "       ----------------- | --------------"]
    #[doc = "              0x03       | BMA2x2_RANGE_2G"]
    #[doc = "              0x05       | BMA2x2_RANGE_4G"]
    #[doc = "              0x08       | BMA2x2_RANGE_8G"]
    #[doc = "              0x0C       | BMA2x2_RANGE_16G"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_range(range_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set the ranges(g values) of the sensor"]
    #[doc = "\tin the register 0x0F bit from 0 to 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param range_u8 : The value of range"]
    #[doc = "\t\t  range_u8       |   result"]
    #[doc = "       ----------------- | --------------"]
    #[doc = "              0x03       | BMA2x2_RANGE_2G"]
    #[doc = "              0x05       | BMA2x2_RANGE_4G"]
    #[doc = "              0x08       | BMA2x2_RANGE_8G"]
    #[doc = "              0x0C       | BMA2x2_RANGE_16G"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_range(range_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get the bandwidth of the sensor in the register"]
    #[doc = "\t0x10 bit from 0 to 4"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param bw_u8 : The value of bandwidth"]
    #[doc = "\t\t  bw_u8          |   result"]
    #[doc = "       ----------------- | --------------"]
    #[doc = "              0x08       | BMA2x2_BW_7_81HZ"]
    #[doc = "              0x09       | BMA2x2_BW_15_63HZ"]
    #[doc = "              0x0A       | BMA2x2_BW_31_25HZ"]
    #[doc = "              0x0B       | BMA2x2_BW_62_50HZ"]
    #[doc = "              0x0C       | BMA2x2_BW_125HZ"]
    #[doc = "              0x0D       | BMA2x2_BW_250HZ"]
    #[doc = "              0x0E       | BMA2x2_BW_500HZ"]
    #[doc = "              0x0F       | BMA2x2_BW_1000HZ"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_bw(bw_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set the bandwidth of the sensor in the register"]
    #[doc = "\t0x10 bit from 0 to 4"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param bw_u8 : The value of bandwidth"]
    #[doc = "\t\t  bw_u8          |   result"]
    #[doc = "       ----------------- | --------------"]
    #[doc = "              0x08       | BMA2x2_BW_7_81HZ"]
    #[doc = "              0x09       | BMA2x2_BW_15_63HZ"]
    #[doc = "              0x0A       | BMA2x2_BW_31_25HZ"]
    #[doc = "              0x0B       | BMA2x2_BW_62_50HZ"]
    #[doc = "              0x0C       | BMA2x2_BW_125HZ"]
    #[doc = "              0x0D       | BMA2x2_BW_250HZ"]
    #[doc = "              0x0E       | BMA2x2_BW_500HZ"]
    #[doc = "              0x0F       | BMA2x2_BW_1000HZ"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_set_bw(bw_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get the operating"]
    #[doc = "\tmodes of the sensor in the register 0x11 and 0x12"]
    #[doc = "\t@note Register 0x11 - bit from 5 to 7"]
    #[doc = "\t@note Register 0x12 - bit from 5 and 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param power_mode_u8 : The value of power mode"]
    #[doc = "\tpower_mode_u8           |value  |   0x11  |   0x12"]
    #[doc = "  ------------------------- |-------| --------|--------"]
    #[doc = "  BMA2x2_MODE_NORMAL        |  0    |  0x00   |  0x00"]
    #[doc = "  BMA2x2_MODE_LOWPOWER1     |  1    |  0x02   |  0x00"]
    #[doc = "  BMA2x2_MODE_SUSPEND       |  2    |  0x06   |  0x00"]
    #[doc = "  BMA2x2_MODE_DEEP_SUSPEND  |  3    |  0x01   |  0x00"]
    #[doc = "  BMA2x2_MODE_LOWPOWER2     |  4    |  0x02   |  0x01"]
    #[doc = "  BMA2x2_MODE_STANDBY       |  5    |  0x04   |  0x00"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_power_mode(power_mode_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set the operating"]
    #[doc = "\tmodes of the sensor in the register 0x11 and 0x12"]
    #[doc = "\t@note Register 0x11 - bit from 5 to 7"]
    #[doc = "\t@note Register 0x12 - bit from 5 and 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param power_mode_u8 : The value of power mode"]
    #[doc = "\tpower_mode_u8           |value  |   0x11  |   0x12"]
    #[doc = "  ------------------------- |-------| --------|--------"]
    #[doc = "  BMA2x2_MODE_NORMAL        |  0    |  0x00   |  0x00"]
    #[doc = "  BMA2x2_MODE_LOWPOWER1     |  1    |  0x02   |  0x00"]
    #[doc = "  BMA2x2_MODE_SUSPEND       |  2    |  0x06   |  0x00"]
    #[doc = "  BMA2x2_MODE_DEEP_SUSPEND  |  3    |  0x01   |  0x00"]
    #[doc = "  BMA2x2_MODE_LOWPOWER2     |  4    |  0x02   |  0x01"]
    #[doc = "  BMA2x2_MODE_STANDBY       |  5    |  0x04   |  0x00"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_power_mode(power_mode_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to assign the power mode values"]
    #[doc = "\tmodes of the sensor in the register 0x11 and 0x12"]
    #[doc = "\t@note Register 0x11 - bit from 5 to 7"]
    #[doc = "\t@note Register 0x12 - bit from 5 and 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param power_mode_u8 : The value of power mode"]
    #[doc = "\tpower_mode_u8           |value  |   0x11  |   0x12"]
    #[doc = "  ------------------------- |-------| --------|--------"]
    #[doc = "  BMA2x2_MODE_NORMAL        |  0    |  0x00   |  0x00"]
    #[doc = "  BMA2x2_MODE_LOWPOWER1     |  1    |  0x02   |  0x00"]
    #[doc = "  BMA2x2_MODE_SUSPEND       |  2    |  0x06   |  0x00"]
    #[doc = "  BMA2x2_MODE_DEEP_SUSPEND  |  3    |  0x01   |  0x00"]
    #[doc = "  BMA2x2_MODE_LOWPOWER2     |  4    |  0x02   |  0x01"]
    #[doc = "  BMA2x2_MODE_STANDBY       |  5    |  0x04   |  0x00"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_mode_value(power_mode_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe sleep duration of the sensor in the register 0x11"]
    #[doc = "\tRegister 0x11 - bit from 0 to 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  sleep_durn_u8 : The value of sleep duration time"]
    #[doc = "        sleep_durn_u8  |   result"]
    #[doc = "       ----------------- | ----------------------"]
    #[doc = "              0x05       | BMA2x2_SLEEP_DURN_0_5MS"]
    #[doc = "              0x06       | BMA2x2_SLEEP_DURN_1MS"]
    #[doc = "              0x07       | BMA2x2_SLEEP_DURN_2MS"]
    #[doc = "              0x08       | BMA2x2_SLEEP_DURN_4MS"]
    #[doc = "              0x09       | BMA2x2_SLEEP_DURN_6MS"]
    #[doc = "              0x0A       | BMA2x2_SLEEP_DURN_10MS"]
    #[doc = "              0x0B       | BMA2x2_SLEEP_DURN_25MS"]
    #[doc = "              0x0C       | BMA2x2_SLEEP_DURN_50MS"]
    #[doc = "              0x0D       | BMA2x2_SLEEP_DURN_100MS"]
    #[doc = "              0x0E       | BMA2x2_SLEEP_DURN_500MS"]
    #[doc = "              0x0F       | BMA2x2_SLEEP_DURN_1S"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_sleep_durn(sleep_durn_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe sleep duration of the sensor in the register 0x11"]
    #[doc = "\tRegister 0x11 - bit from 0 to 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  sleep_durn_u8 : The value of sleep duration time"]
    #[doc = "        sleep_durn_u8  |   result"]
    #[doc = "       ----------------- | ----------------------"]
    #[doc = "              0x05       | BMA2x2_SLEEP_DURN_0_5MS"]
    #[doc = "              0x06       | BMA2x2_SLEEP_DURN_1MS"]
    #[doc = "              0x07       | BMA2x2_SLEEP_DURN_2MS"]
    #[doc = "              0x08       | BMA2x2_SLEEP_DURN_4MS"]
    #[doc = "              0x09       | BMA2x2_SLEEP_DURN_6MS"]
    #[doc = "              0x0A       | BMA2x2_SLEEP_DURN_10MS"]
    #[doc = "              0x0B       | BMA2x2_SLEEP_DURN_25MS"]
    #[doc = "              0x0C       | BMA2x2_SLEEP_DURN_50MS"]
    #[doc = "              0x0D       | BMA2x2_SLEEP_DURN_100MS"]
    #[doc = "              0x0E       | BMA2x2_SLEEP_DURN_500MS"]
    #[doc = "              0x0F       | BMA2x2_SLEEP_DURN_1S"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_sleep_durn(sleep_durn_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get the sleep timer mode"]
    #[doc = "\tin the register 0x12 bit 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  sleep_timer_u8 : The value of sleep timer mode"]
    #[doc = "        sleep_timer_u8 |   result"]
    #[doc = "       ----------------- | ----------------------"]
    #[doc = "              0          | enable EventDrivenSampling(EDT)"]
    #[doc = "              1          | enable Equidistant sampling mode(EST)"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_sleep_timer_mode(sleep_timer_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set the sleep timer mode"]
    #[doc = "\tin the register 0x12 bit 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  sleep_timer_u8 : The value of sleep timer mode"]
    #[doc = "        sleep_timer_u8 |   result"]
    #[doc = "       ----------------- | ----------------------"]
    #[doc = "              0          | enable EventDrivenSampling(EDT)"]
    #[doc = "              1          | enable Equidistant sampling mode(EST)"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_sleep_timer_mode(sleep_timer_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get high bandwidth"]
    #[doc = "\t\tin the register 0x13 bit 7"]
    #[doc = ""]
    #[doc = "  @param  high_bw_u8 : The value of high bandwidth"]
    #[doc = "         high_bw_u8    |   result"]
    #[doc = "       ----------------- | ----------------------"]
    #[doc = "              0          | Unfiltered High Bandwidth"]
    #[doc = "              1          | Filtered Low Bandwidth"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_high_bw(high_bw_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to write high bandwidth"]
    #[doc = "\t\tin the register 0x13 bit 7"]
    #[doc = ""]
    #[doc = "  @param  high_bw_u8 : The value of high bandwidth"]
    #[doc = "         high_bw_u8    |   result"]
    #[doc = "       ----------------- | ----------------------"]
    #[doc = "              0          | Unfiltered High Bandwidth"]
    #[doc = "              1          | Filtered Low Bandwidth"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_high_bw(high_bw_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get shadow dis"]
    #[doc = "\tin the register 0x13 bit 6"]
    #[doc = ""]
    #[doc = "  @param  shadow_dis_u8 : The value of shadow dis"]
    #[doc = "        shadow_dis_u8  |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | MSB is Locked"]
    #[doc = "              1          | No MSB Locking"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_shadow_dis(shadow_dis_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set shadow dis"]
    #[doc = "\tin the register 0x13 bit 6"]
    #[doc = ""]
    #[doc = "  @param  shadow_dis_u8 : The value of shadow dis"]
    #[doc = "        shadow_dis_u8  |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | MSB is Locked"]
    #[doc = "              1          | No MSB Locking"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_shadow_dis(shadow_dis_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This function is used for the soft reset"]
    #[doc = "\tThe soft reset register will be written"]
    #[doc = "\twith 0xB6 in the register 0x14."]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_soft_rst() -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to update the register values"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param : None"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_update_image() -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "  interrupt enable bits of the sensor in the registers 0x16 and 0x17"]
    #[doc = "\t@note It reads the flat enable, orient enable,"]
    #[doc = "\t@note single tap enable, double tap enable"]
    #[doc = "\t@note slope-x enable, slope-y enable, slope-z enable,"]
    #[doc = "\t@note fifo watermark enable,"]
    #[doc = "\t@note fifo full enable, data enable, low-g enable,"]
    #[doc = "\t@note high-z enable, high-y enable"]
    #[doc = "\t@note high-z enable"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param intr_type_u8: The value of interrupts"]
    #[doc = "        intr_type_u8   |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_LOW_G_INTR"]
    #[doc = "              1          | BMA2x2_HIGH_G_X_INTR"]
    #[doc = "              2          | BMA2x2_HIGH_G_Y_INTR"]
    #[doc = "              3          | BMA2x2_HIGH_G_Z_INTR"]
    #[doc = "              4          | BMA2x2_DATA_ENABLE"]
    #[doc = "              5          | SLOPE_X_INTR"]
    #[doc = "              6          | SLOPE_Y_INTR"]
    #[doc = "              7          | SLOPE_Z_INTR"]
    #[doc = "              8          | SINGLE_TAP_INTR"]
    #[doc = "              9          | SINGLE_TAP_INTR"]
    #[doc = "              10         | ORIENT_INT"]
    #[doc = "              11         | FLAT_INT"]
    #[doc = ""]
    #[doc = "  @param value_u8 : The value of interrupts enable"]
    #[doc = "        value_u8       |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0x00       | INTR_DISABLE"]
    #[doc = "              0x01       | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_enable(intr_type_u8: u8, value_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "  interrupt enable bits of the sensor in the registers 0x16 and 0x17"]
    #[doc = "\t@note It reads the flat enable, orient enable,"]
    #[doc = "\t@note single tap enable, double tap enable"]
    #[doc = "\t@note slope-x enable, slope-y enable, slope-z enable,"]
    #[doc = "\t@note fifo watermark enable,"]
    #[doc = "\t@note fifo full enable, data enable, low-g enable,"]
    #[doc = "\t@note high-z enable, high-y enable"]
    #[doc = "\t@note high-z enable"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param intr_type_u8: The value of interrupts"]
    #[doc = "        intr_type_u8   |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_LOW_G_INTR"]
    #[doc = "              1          | BMA2x2_HIGH_G_X_INTR"]
    #[doc = "              2          | BMA2x2_HIGH_G_Y_INTR"]
    #[doc = "              3          | BMA2x2_HIGH_G_Z_INTR"]
    #[doc = "              4          | BMA2x2_DATA_ENABLE"]
    #[doc = "              5          | SLOPE_X_INTR"]
    #[doc = "              6          | SLOPE_Y_INTR"]
    #[doc = "              7          | SLOPE_Z_INTR"]
    #[doc = "              8          | SINGLE_TAP_INTR"]
    #[doc = "              9          | SINGLE_TAP_INTR"]
    #[doc = "              10         | ORIENT_INT"]
    #[doc = "              11         | FLAT_INT"]
    #[doc = ""]
    #[doc = "  @param value_u8 : The value of interrupts enable"]
    #[doc = "        value_u8       |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0x00       | INTR_DISABLE"]
    #[doc = "              0x01       | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_enable(intr_type_u8: u8, value_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe interrupt fifo full enable interrupt status"]
    #[doc = "\tin the register 0x17 bit 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_full_u8 The value of fifo full interrupt enable"]
    #[doc = "        fifo_full_u8   |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0x00       | INTR_DISABLE"]
    #[doc = "              0x01       | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_fifo_full(fifo_full_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe interrupt fifo full enable interrupt status"]
    #[doc = "\tin the register 0x17 bit 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_full_u8 The value of fifo full interrupt enable"]
    #[doc = "        fifo_full_u8   |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0x00       | INTR_DISABLE"]
    #[doc = "              0x01       | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_fifo_full(fifo_full_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = "\tthe interrupt fifo watermark enable interrupt status"]
    #[doc = "\tin the register 0x17 bit 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_wm_u8 : the value FIFO Water Mark"]
    #[doc = "        fifo_wm_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0x00       | INTR_DISABLE"]
    #[doc = "              0x01       | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_fifo_wm(fifo_wm_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = "\tthe interrupt fifo watermark enable interrupt status"]
    #[doc = "\tin the register 0x17 bit 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_wm_u8 : the value FIFO Water Mark"]
    #[doc = "        fifo_wm_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0x00       | INTR_DISABLE"]
    #[doc = "              0x01       | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_fifo_wm(fifo_wm_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the interrupt status of slow/no motion select and slow no motion"]
    #[doc = " enable xyz interrupt in the register 0x18 bit from 0 to 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  channel_u8 : The value of slow/no motion select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_X"]
    #[doc = "              1          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Y"]
    #[doc = "              2          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Z"]
    #[doc = "              3          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_SEL"]
    #[doc = ""]
    #[doc = "\t@param slow_no_motion_u8 : The value of slow no motion interrupt"]
    #[doc = "      enable"]
    #[doc = "        slow_no_motion_u8     |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_slow_no_motion(channel_u8: u8, slow_no_motion_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the interrupt status of slow/no motion select and slow no motion"]
    #[doc = " enable xyz interrupt in the register 0x18 bit from 0 to 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  channel_u8 : The value of slow/no motion select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_X"]
    #[doc = "              1          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Y"]
    #[doc = "              2          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Z"]
    #[doc = "              3          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_SEL"]
    #[doc = ""]
    #[doc = "\t@param slow_no_motion_u8 : The value of slow no motion interrupt enable"]
    #[doc = "        slow_no_motion_u8     |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_slow_no_motion(channel_u8: u8, slow_no_motion_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief  This API is used to get"]
    #[doc = " the interrupt enable of low_g interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_Low_g -> register 0x19 bit 0"]
    #[doc = " @note INTR2_Low_g -> register 0x1B bit 0"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param channel_u8 : The value of low interrupt selection channel"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_LOW_G"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_LOW_G"]
    #[doc = ""]
    #[doc = " @param intr_low_g_u8 : the value of low_g interrupt"]
    #[doc = "        intr_low_u8           |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_low_g(channel_u8: u8, intr_low_g_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief  This API is used to set"]
    #[doc = " the interrupt enable of low_g interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_Low_g -> register 0x19 bit 0"]
    #[doc = " @note INTR2_Low_g -> register 0x1B bit 0"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param channel_u8 : The value of low interrupt selection channel"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_LOW_G"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_LOW_G"]
    #[doc = ""]
    #[doc = " @param intr_low_u8 : the value of low_g interrupt"]
    #[doc = "        intr_low_u8           |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_low_g(channel_u8: u8, intr_low_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the interrupt enable of high_g interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_high_g -> register 0x19 bit 1"]
    #[doc = " @note INTR2_high_g -> register 0x1B bit 1"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  channel_u8: The value of high_g interrupt selection"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_HIGH_G"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_HIGH_G"]
    #[doc = ""]
    #[doc = " @param intr_high_g_u8 : the value of high_g interrupt"]
    #[doc = "        intr_high_g_u8        |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_high_g(channel_u8: u8, intr_high_g_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the interrupt enable of high_g interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_high_g -> register 0x19 bit 1"]
    #[doc = " @note INTR2_high_g -> register 0x1B bit 1"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  channel_u8: The value of high_g interrupt selection"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_HIGH_G"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_HIGH_G"]
    #[doc = ""]
    #[doc = " @param intr_high_g_u8 : the value of high_g interrupt"]
    #[doc = "        intr_high_g_u8        |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_high_g(channel_u8: u8, intr_high_g_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the interrupt enable of slope interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_slope -> register 0x19 bit 2"]
    #[doc = " @note INTR2_slope -> register 0x1B bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param channel_u8: the value of slope channel select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_SLOPE"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_SLOPE"]
    #[doc = ""]
    #[doc = " @param intr_slope_u8 : The slope value enable value"]
    #[doc = "        intr_slope_u8         |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_slope(channel_u8: u8, intr_slope_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the interrupt enable of slope interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_slope -> register 0x19 bit 2"]
    #[doc = " @note INTR2_slope -> register 0x1B bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param channel_u8: the value of slope channel select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_SLOPE"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_SLOPE"]
    #[doc = ""]
    #[doc = " @param intr_slope_u8 : The slope value enable value"]
    #[doc = "        intr_slope_u8         |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_slope(channel_u8: u8, intr_slope_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the interrupt enable of slow/no motion interrupt in"]
    #[doc = " the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_slow_no_motion -> register 0x19 bit 3"]
    #[doc = " @note INTR2_slow_no_motion -> register 0x1B bit 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8 : The value of slow/no motion selection"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_INTR1_SLOW_NO_MOTION"]
    #[doc = "              1          | BMA2x2_INTR2_SLOW_NO_MOTION"]
    #[doc = ""]
    #[doc = "  @param intr_slow_no_motion_u8:  the slow_no_motion enable value"]
    #[doc = "       intr_slow_no_motion_u8 |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_slow_no_motion(channel_u8: u8, intr_slow_no_motion_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the interrupt enable of slow/no motion interrupt in"]
    #[doc = " the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_slow_no_motion -> register 0x19 bit 3"]
    #[doc = " @note INTR2_slow_no_motion -> register 0x1B bit 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8 : The value of slow/no motion selection"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_INTR1_SLOW_NO_MOTION"]
    #[doc = "              1          | BMA2x2_INTR2_SLOW_NO_MOTION"]
    #[doc = ""]
    #[doc = "  @param intr_slow_no_motion_u8:  the slow_no_motion enable value"]
    #[doc = "       intr_slow_no_motion_u8 |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_slow_no_motion(channel_u8: u8, intr_slow_no_motion_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the interrupt enable of double tap interrupt"]
    #[doc = " in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_double -> register 0x19 bit 4"]
    #[doc = " @note INTR2_double -> register 0x1B bit 4"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of double tap selection"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_DOUBLE_TAP"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_DOUBLE_TAP"]
    #[doc = ""]
    #[doc = "\t@param intr_double_tap_u8: The double tap interrupt enable value"]
    #[doc = "       intr_double_tap_u8     |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_double_tap(channel_u8: u8, intr_double_tap_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the interrupt enable of double tap interrupt"]
    #[doc = " in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_double -> register 0x19 bit 4"]
    #[doc = " @note INTR2_double -> register 0x1B bit 4"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of double tap selection"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_DOUBLE_TAP"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_DOUBLE_TAP"]
    #[doc = ""]
    #[doc = "\t@param intr_double_tap_u8: The double tap interrupt enable value"]
    #[doc = "       intr_double_tap_u8     |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_double_tap(channel_u8: u8, intr_double_tap_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the interrupt enable of single tap"]
    #[doc = " interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_single_tap -> register 0x19 bit 5"]
    #[doc = " @note INTR2_single_tap -> register 0x1B bit 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of single tap interrupt select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_SINGLE_TAP"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_SINGLE_TAP"]
    #[doc = ""]
    #[doc = "  @param intr_single_tap_u8: The single tap interrupt enable value"]
    #[doc = "       intr_single_tap_u8     |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_single_tap(channel_u8: u8, intr_single_tap_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the interrupt enable of single tap"]
    #[doc = " interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_single_tap -> register 0x19 bit 5"]
    #[doc = " @note INTR2_single_tap -> register 0x1B bit 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of single tap interrupt select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_SINGLE_TAP"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_SINGLE_TAP"]
    #[doc = ""]
    #[doc = "  @param intr_single_tap_u8: The single tap interrupt enable value"]
    #[doc = "       intr_single_tap_u8     |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_single_tap(channel_u8: u8, intr_single_tap_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the interrupt status of orient interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_orient -> register 0x19 bit 6"]
    #[doc = " @note INTR2_orient -> register 0x1B bit 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param channel_u8: The value of orient interrupt select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_ORIENT"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_ORIENT"]
    #[doc = ""]
    #[doc = "  @param intr_orient_u8: The value of orient interrupt enable"]
    #[doc = "       intr_orient_u8         |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_intr_orient(channel_u8: u8, intr_orient_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the interrupt status of orient interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_orient -> register 0x19 bit 6"]
    #[doc = " @note INTR2_orient -> register 0x1B bit 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param channel_u8: The value of orient interrupt select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_ORIENT"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_ORIENT"]
    #[doc = ""]
    #[doc = "  @param intr_orient_u8: The value of orient interrupt enable"]
    #[doc = "       intr_orient_u8         |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_set_intr_orient(channel_u8: u8, intr_orient_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the interrupt enable of flat interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_flat -> register 0x19 bit 7"]
    #[doc = " @note INTR2_flat -> register 0x1B bit 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param channel_u8: The value of flat interrupt select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_FLAT"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_FLAT"]
    #[doc = ""]
    #[doc = " @param intr_flat_u8: The flat interrupt enable value"]
    #[doc = "       intr_flat_u8           |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_intr_flat(channel_u8: u8, intr_flat_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the interrupt enable of flat interrupt in the register 0x19 and 0x1B"]
    #[doc = " @note INTR1_flat -> register 0x19 bit 7"]
    #[doc = " @note INTR2_flat -> register 0x1B bit 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param channel_u8: The value of flat interrupt select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_FLAT"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_FLAT"]
    #[doc = ""]
    #[doc = " @param intr_flat_u8: The flat interrupt enable value"]
    #[doc = "       intr_flat_u8           |   result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_set_intr_flat(channel_u8: u8, intr_flat_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the interrupt status of new data in the register 0x19"]
    #[doc = " @note INTR1_data -> register 0x19 bit 0"]
    #[doc = " @note INTR2_data -> register 0x19 bit 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of new data interrupt select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_NEWDATA"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_NEWDATA"]
    #[doc = ""]
    #[doc = "\t@param intr_newdata_u8: The new data interrupt enable value"]
    #[doc = "       intr_newdata_u8          |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_new_data(channel_u8: u8, intr_newdata_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the interrupt status of new data in the register 0x19"]
    #[doc = " @note INTR1_data -> register 0x19 bit 0"]
    #[doc = " @note INTR2_data -> register 0x19 bit 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of new data interrupt select"]
    #[doc = "        channel_u8     |   result"]
    #[doc = "       ----------------- | ------------------"]
    #[doc = "              0          | BMA2x2_ACCEL_INTR1_NEWDATA"]
    #[doc = "              1          | BMA2x2_ACCEL_INTR2_NEWDATA"]
    #[doc = ""]
    #[doc = "\t@param intr_newdata_u8: The new data interrupt enable value"]
    #[doc = "       intr_newdata_u8          |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_new_data(channel_u8: u8, intr_newdata_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get the fifo watermark interrupt1 data"]
    #[doc = " in the register 0x1A bit 1"]
    #[doc = ""]
    #[doc = "  @param  intr1_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable"]
    #[doc = "       intr1_fifo_wm_u8       |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_intr1_fifo_wm(intr1_fifo_wm_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set the fifo watermark interrupt1 data"]
    #[doc = " in the register 0x1A bit 1"]
    #[doc = ""]
    #[doc = "  @param  intr1_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable"]
    #[doc = "       intr1_fifo_wm_u8       |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_set_intr1_fifo_wm(intr1_fifo_wm_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get the fifo watermark interrupt2 data"]
    #[doc = " in the register 0x1A bit 6"]
    #[doc = ""]
    #[doc = "  @param  intr2_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable"]
    #[doc = "       intr2_fifo_wm_u8       |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr2_fifo_wm(intr2_fifo_wm_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set the fifo watermark interrupt2 data"]
    #[doc = " in the register 0x1A bit 6"]
    #[doc = ""]
    #[doc = "  @param  intr2_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable"]
    #[doc = "       intr2_fifo_wm_u8       |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr2_fifo_wm(intr2_fifo_wm_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe fifo full interrupt1 in the register 0x1A bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param intr1_fifo_full_u8 : The value of fifo full interrupt enable"]
    #[doc = "       intr1_fifo_full_u8     |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr1_fifo_full(intr1_fifo_full_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe fifo full interrupt1 in the register 0x1A bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param intr1_fifo_full_u8 : The value of fifo full interrupt enable"]
    #[doc = "       intr1_fifo_full_u8     |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr1_fifo_full(intr1_fifo_full_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe fifo full interrupt2 in the register 0x1A bit 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param intr2_fifo_full_u8 : Thee vale of fifo full enable"]
    #[doc = "       intr2_fifo_full_u8     |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr2_fifo_full(intr2_fifo_full_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe fifo full interrupt2 in the register 0x1A bit 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param intr2_fifo_full_u8 : Thee vale of fifo full enable"]
    #[doc = "       intr2_fifo_full_u8     |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr2_fifo_full(intr2_fifo_full_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe source data status of source data,"]
    #[doc = "\tsource slow no motion, source slope, source high"]
    #[doc = "\tand source low in the register 0x1E bit from 0 to 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8 : The value of source select"]
    #[doc = "       channel_u8     |    result"]
    #[doc = "       -----------------| ------------------"]
    #[doc = "               0        | BMA2x2_ACCEL_SOURCE_LOW_G"]
    #[doc = "               1        | BMA2x2_ACCEL_SOURCE_HIGH_G"]
    #[doc = "               2        | BMA2x2_ACCEL_SOURCE_SLOPE"]
    #[doc = "               3        | BMA2x2_ACCEL_SOURCE_SLOW_NO_MOTION"]
    #[doc = "               4        | BMA2x2_ACCEL_SOURCE_TAP"]
    #[doc = "               5        | BMA2x2_ACCEL_SOURCE_DATA"]
    #[doc = ""]
    #[doc = "\t@param intr_source_u8: The source status enable value"]
    #[doc = "       intr_source_u8         |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_source(channel_u8: u8, intr_source_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe source data status of source data,"]
    #[doc = "\tsource slow no motion, source slope, source high"]
    #[doc = "\tand source low in the register 0x1E bit from 0 to 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8 : The value of source select"]
    #[doc = "       channel_u8     |    result"]
    #[doc = "       -----------------| ------------------"]
    #[doc = "               0        | BMA2x2_ACCEL_SOURCE_LOW_G"]
    #[doc = "               1        | BMA2x2_ACCEL_SOURCE_HIGH_G"]
    #[doc = "               2        | BMA2x2_ACCEL_SOURCE_SLOPE"]
    #[doc = "               3        | BMA2x2_ACCEL_SOURCE_SLOW_NO_MOTION"]
    #[doc = "               4        | BMA2x2_ACCEL_SOURCE_TAP"]
    #[doc = "               5        | BMA2x2_ACCEL_SOURCE_DATA"]
    #[doc = ""]
    #[doc = "\t@param intr_source_u8: The source status enable value"]
    #[doc = "       intr_source_u8         |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x00              | INTR_DISABLE"]
    #[doc = "              0x01              | INTR_ENABLE"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_set_source(channel_u8: u8, intr_source_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe interrupt output type in the register 0x20."]
    #[doc = "\t@note INTR1 -> bit 1"]
    #[doc = "\t@note INTR2 -> bit 3"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of output type select"]
    #[doc = "       channel_u8     |    result"]
    #[doc = "       -----------------| ------------------"]
    #[doc = "               0        | BMA2x2_ACCEL_INTR1_OUTPUT"]
    #[doc = "               1        | BMA2x2_ACCEL_INTR2_OUTPUT"]
    #[doc = ""]
    #[doc = "\t@param intr_output_type_u8: The value of output type select"]
    #[doc = "       intr_source_u8         |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x01              | OPEN_DRAIN"]
    #[doc = "              0x00              | PUSS_PULL"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_output_type(channel_u8: u8, intr_output_type_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe interrupt output type in the register 0x20."]
    #[doc = "\t@note INTR1 -> bit 1"]
    #[doc = "\t@note INTR2 -> bit 3"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of output type select"]
    #[doc = "         channel_u8   |    result"]
    #[doc = "       -----------------| ------------------"]
    #[doc = "               0        | BMA2x2_ACCEL_INTR1_OUTPUT"]
    #[doc = "               1        | BMA2x2_ACCEL_INTR2_OUTPUT"]
    #[doc = ""]
    #[doc = "\t@param intr_output_type_u8: The value of output type select"]
    #[doc = "       intr_source_u8         |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x01              | OPEN_DRAIN"]
    #[doc = "              0x00              | PUSS_PULL"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_output_type(channel_u8: u8, intr_output_type_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tActive Level status in the register 0x20"]
    #[doc = "\t@note INTR1 -> bit 0"]
    #[doc = "\t@note INTR2 -> bit 2"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of Active Level select"]
    #[doc = "       channel_u8     |    result"]
    #[doc = "       -----------------| ------------------"]
    #[doc = "               0        | BMA2x2_ACCEL_INTR1_LEVEL"]
    #[doc = "               1        | BMA2x2_ACCEL_INTR2_LEVEL"]
    #[doc = ""]
    #[doc = "  @param intr_level_u8: The Active Level status enable value"]
    #[doc = "       intr_level_u8          |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x01              | ACTIVE_HIGH"]
    #[doc = "              0x00              | ACTIVE_LOW"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_intr_level(channel_u8: u8, intr_level_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tActive Level status in the register 0x20"]
    #[doc = "\t@note INTR1 -> bit 0"]
    #[doc = "\t@note INTR2 -> bit 2"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of Active Level select"]
    #[doc = "       channel_u8     |    result"]
    #[doc = "       -----------------| ------------------"]
    #[doc = "               0        | BMA2x2_ACCEL_INTR1_LEVEL"]
    #[doc = "               1        | BMA2x2_ACCEL_INTR2_LEVEL"]
    #[doc = ""]
    #[doc = "  @param intr_level_u8: The Active Level status enable value"]
    #[doc = "       intr_level_u8          |    result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x01              | ACTIVE_HIGH"]
    #[doc = "              0x00              | ACTIVE_LOW"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_intr_level(channel_u8: u8, intr_level_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe reset interrupt in the register 0x21 bit 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  rst_intr_u8: The value of reset interrupt"]
    #[doc = "          rst_intr_u8         |  result"]
    #[doc = "       ------------------------ | ------------------"]
    #[doc = "              0x01              | clear any latch interrupt"]
    #[doc = "              0x00              | keep latch interrupt active"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_rst_intr(rst_intr_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe latch duration in the register 0x21 bit from 0 to 3"]
    #[doc = ""]
    #[doc = "\t@param latch_intr_u8: The value of latch duration"]
    #[doc = "        latch_intr_u8 |  result"]
    #[doc = "       -----------------| ------------------"]
    #[doc = "               0x00     | BMA2x2_LATCH_DURN_NON_LATCH"]
    #[doc = "               0x01     | BMA2x2_LATCH_DURN_250MS"]
    #[doc = "               0x02     | BMA2x2_LATCH_DURN_500MS"]
    #[doc = "               0x03     | BMA2x2_LATCH_DURN_1S"]
    #[doc = "               0x04     | BMA2x2_LATCH_DURN_2S"]
    #[doc = "               0x05     | BMA2x2_LATCH_DURN_4S"]
    #[doc = "               0x06     | BMA2x2_LATCH_DURN_8S"]
    #[doc = "               0x07     | BMA2x2_LATCH_DURN_LATCH"]
    #[doc = "               0x08     | BMA2x2_LATCH_DURN_NON_LATCH1"]
    #[doc = "               0x09     | BMA2x2_LATCH_DURN_250US"]
    #[doc = "               0x0A     | BMA2x2_LATCH_DURN_500US"]
    #[doc = "               0x0B     | BMA2x2_LATCH_DURN_1MS"]
    #[doc = "               0x0C     | BMA2x2_LATCH_DURN_12_5MS"]
    #[doc = "               0x0D     | BMA2x2_LATCH_DURN_25MS"]
    #[doc = "               0x0E     | BMA2x2_LATCH_DURN_50MS"]
    #[doc = "               0x0F     | BMA2x2_LATCH_DURN_LATCH1"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_latch_intr(latch_intr_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe latch duration in the register 0x21 bit from 0 to 3"]
    #[doc = ""]
    #[doc = "\t@param latch_intr_u8: The value of latch duration"]
    #[doc = "        latch_intr_u8 |  result"]
    #[doc = "       -----------------| ------------------"]
    #[doc = "               0x00     | BMA2x2_LATCH_DURN_NON_LATCH"]
    #[doc = "               0x01     | BMA2x2_LATCH_DURN_250MS"]
    #[doc = "               0x02     | BMA2x2_LATCH_DURN_500MS"]
    #[doc = "               0x03     | BMA2x2_LATCH_DURN_1S"]
    #[doc = "               0x04     | BMA2x2_LATCH_DURN_2S"]
    #[doc = "               0x05     | BMA2x2_LATCH_DURN_4S"]
    #[doc = "               0x06     | BMA2x2_LATCH_DURN_8S"]
    #[doc = "               0x07     | BMA2x2_LATCH_DURN_LATCH"]
    #[doc = "               0x08     | BMA2x2_LATCH_DURN_NON_LATCH1"]
    #[doc = "               0x09     | BMA2x2_LATCH_DURN_250US"]
    #[doc = "               0x0A     | BMA2x2_LATCH_DURN_500US"]
    #[doc = "               0x0B     | BMA2x2_LATCH_DURN_1MS"]
    #[doc = "               0x0C     | BMA2x2_LATCH_DURN_12_5MS"]
    #[doc = "               0x0D     | BMA2x2_LATCH_DURN_25MS"]
    #[doc = "               0x0E     | BMA2x2_LATCH_DURN_50MS"]
    #[doc = "               0x0F     | BMA2x2_LATCH_DURN_LATCH1"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_latch_intr(latch_intr_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get the duration of"]
    #[doc = "\tLow, High, Slope and slow no motion interrupts in the registers"]
    #[doc = "\t@note LOW_DURN\t\t-> register 0x22 bit form 0 to 7"]
    #[doc = "\t@note HIGH_DURN\t\t-> register 0x25 bit form 0 to 7"]
    #[doc = "\t@note SLOPE_DURN\t\t-> register 0x27 bit form 0 to 1"]
    #[doc = "\t@note SLO_NO_MOT_DURN -> register 0x27 bit form 2 to 7"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of duration select"]
    #[doc = "     channel_u8   | result"]
    #[doc = "   -----------------| ------------------"]
    #[doc = "               0    | BMA2x2_ACCEL_LOW_DURN"]
    #[doc = "               1    | BMA2x2_ACCEL_HIGH_DURN"]
    #[doc = "               2    | BMA2x2_ACCEL_SLOPE_DURN"]
    #[doc = "               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_DURN"]
    #[doc = ""]
    #[doc = "\t@param durn_u8: The value of duration"]
    #[doc = ""]
    #[doc = "\t@note :"]
    #[doc = "     Duration           |    result"]
    #[doc = " -----------------------| ------------------"]
    #[doc = " BMA2x2_ACCEL_LOW_DURN  | Low-g interrupt trigger"]
    #[doc = "         -              | delay according to([durn_u8 +1]*2)ms"]
    #[doc = "         -              | range from 2ms to 512ms. default is 20ms"]
    #[doc = " BMA2x2_ACCEL_HIGH_DURN | high-g interrupt trigger"]
    #[doc = "         -              | delay according to([durn_u8 +1]*2)ms"]
    #[doc = "         -              | range from 2ms to 512ms. default is 32ms"]
    #[doc = " BMA2x2_ACCEL_SLOPE_DURN| slope interrupt trigger"]
    #[doc = "         -              | if[durn_u8<1:0>+1] consecutive data points"]
    #[doc = "         -              | are above the slope interrupt threshold"]
    #[doc = " SLO_NO_MOT_DURN        | Refer data sheet for clear information"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_durn(channel_u8: u8, durn_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set the duration of"]
    #[doc = "\tLow, High, Slope and slow no motion interrupts in the registers"]
    #[doc = "\t@note LOW_DURN\t\t-> register 0x22 bit form 0 to 7"]
    #[doc = "\t@note HIGH_DURN\t\t-> register 0x25 bit form 0 to 7"]
    #[doc = "\t@note SLOPE_DURN\t\t-> register 0x27 bit form 0 to 1"]
    #[doc = "\t@note SLO_NO_MOT_DURN -> register 0x27 bit form 2 to 7"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of duration select"]
    #[doc = "     channel_u8   | result"]
    #[doc = "   -----------------| ------------------"]
    #[doc = "               0    | BMA2x2_ACCEL_LOW_DURN"]
    #[doc = "               1    | BMA2x2_ACCEL_HIGH_DURN"]
    #[doc = "               2    | BMA2x2_ACCEL_SLOPE_DURN"]
    #[doc = "               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_DURN"]
    #[doc = ""]
    #[doc = "\t@param durn_u8: The value of duration"]
    #[doc = ""]
    #[doc = "\t@note :"]
    #[doc = "     Duration           |    result"]
    #[doc = " -----------------------| ------------------"]
    #[doc = " BMA2x2_ACCEL_LOW_DURN  | Low-g interrupt trigger"]
    #[doc = "         -              | delay according to([durn_u8 +1]*2)ms"]
    #[doc = "         -              | range from 2ms to 512ms. default is 20ms"]
    #[doc = " BMA2x2_ACCEL_HIGH_DURN | high-g interrupt trigger"]
    #[doc = "         -              | delay according to([durn_u8 +1]*2)ms"]
    #[doc = "         -              | range from 2ms to 512ms. default is 32ms"]
    #[doc = " BMA2x2_ACCEL_SLOPE_DURN| slope interrupt trigger"]
    #[doc = "         -              | if[durn_u8<1:0>+1] consecutive data points"]
    #[doc = "         -              | are above the slope interrupt threshold"]
    #[doc = " SLO_NO_MOT_DURN        | Refer data sheet for clear information"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_durn(channel_u8: u8, durn_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get the threshold of"]
    #[doc = "\tLow, High, Slope and slow no motion interrupts in the registers"]
    #[doc = "\t@note LOW_THRES\t\t-> register 0x23 bit form 0 to 7"]
    #[doc = "\t@note HIGH_THRES\t\t-> register 0x26 bit form 0 to 7"]
    #[doc = "\t@note SLOPE_THRES\t\t-> register 0x28 bit form 0 to 7"]
    #[doc = "\t@note SLO_NO_MOT_THRES -> register 0x29 bit form 0 to 7"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of threshold selection"]
    #[doc = "     channel_u8   | result"]
    #[doc = "   -----------------| ------------------"]
    #[doc = "               0    | BMA2x2_ACCEL_LOW_THRES"]
    #[doc = "               1    | BMA2x2_ACCEL_HIGH_THRES"]
    #[doc = "               2    | BMA2x2_ACCEL_SLOPE_THRES"]
    #[doc = "               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_THRES"]
    #[doc = ""]
    #[doc = "  @param thres_u8: The threshold value of selected interrupts"]
    #[doc = ""]
    #[doc = "\t@note : LOW-G THRESHOLD"]
    #[doc = "     Threshold                    |    result"]
    #[doc = " ---------------------------------| ------------------"]
    #[doc = " BMA2x2_ACCEL_LOW_THRES           | Low-threshold interrupt trigger"]
    #[doc = "                                  | according to(thres_u8 * 7.81) mg"]
    #[doc = "                                  | range from 0g to 1.992g"]
    #[doc = "                                  | default is 375mg"]
    #[doc = "\t@note : HIGH-G THRESHOLD"]
    #[doc = "\t@note Threshold of high-g interrupt according to accel g range"]
    #[doc = "    g-range           |      High-g threshold"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     2g               |    (thres_u8 * 7.81) mg"]
    #[doc = "     4g               |    (thres_u8 * 15.63) mg"]
    #[doc = "     8g               |    (thres_u8 * 31.25) mg"]
    #[doc = "     16g              |    (thres_u8 * 62.5) mg"]
    #[doc = ""]
    #[doc = "\t@note : SLOPE THRESHOLD"]
    #[doc = "\t@note Threshold of slope interrupt according to accel g range"]
    #[doc = "    g-range           |      Slope threshold"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     2g               |    (thres_u8 * 3.19) mg"]
    #[doc = "     4g               |    (thres_u8 * 7.81) mg"]
    #[doc = "     8g               |    (thres_u8 * 15.63) mg"]
    #[doc = "     16g              |    (thres_u8 * 31.25) mg"]
    #[doc = ""]
    #[doc = "\t@note : SLOW NO MOTION THRESHOLD"]
    #[doc = "\t@note Threshold of slow no motion interrupt according to accel g range"]
    #[doc = "    g-range           |   slow no motion threshold"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     2g               |    (thres_u8 * 3.19) mg"]
    #[doc = "     4g               |    (thres_u8 * 7.81) mg"]
    #[doc = "     8g               |    (thres_u8 * 15.63) mg"]
    #[doc = "     16g              |    (thres_u8 * 31.25) mg"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_thres(channel_u8: u8, thres_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set the threshold of"]
    #[doc = "\tLow, High, Slope and slow no motion interrupts in the registers"]
    #[doc = "\t@note LOW_THRES\t\t-> register 0x23 bit form 0 to 7"]
    #[doc = "\t@note HIGH_THRES\t\t-> register 0x26 bit form 0 to 7"]
    #[doc = "\t@note SLOPE_THRES\t\t-> register 0x28 bit form 0 to 7"]
    #[doc = "\t@note SLO_NO_MOT_THRES -> register 0x29 bit form 0 to 7"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of threshold selection"]
    #[doc = "     channel_u8   | result"]
    #[doc = "   -----------------| ------------------"]
    #[doc = "               0    | BMA2x2_ACCEL_LOW_THRES"]
    #[doc = "               1    | BMA2x2_ACCEL_HIGH_THRES"]
    #[doc = "               2    | BMA2x2_ACCEL_SLOPE_THRES"]
    #[doc = "               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_THRES"]
    #[doc = ""]
    #[doc = "  @param thres_u8: The threshold value of selected interrupts"]
    #[doc = ""]
    #[doc = "\t@note : LOW-G THRESHOLD"]
    #[doc = "     Threshold                    |    result"]
    #[doc = " ---------------------------------| ------------------"]
    #[doc = " BMA2x2_ACCEL_LOW_THRES           | Low-threshold interrupt trigger"]
    #[doc = "                                  | according to(thres_u8 * 7.81) mg"]
    #[doc = "                                  | range from 0g to 1.992g"]
    #[doc = "                                  | default is 375mg"]
    #[doc = "\t@note : HIGH-G THRESHOLD"]
    #[doc = "\t@note Threshold of high-g interrupt according to accel g range"]
    #[doc = "    g-range           |      High-g threshold"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     2g               |    (thres_u8 * 7.81) mg"]
    #[doc = "     4g               |    (thres_u8 * 15.63) mg"]
    #[doc = "     8g               |    (thres_u8 * 31.25) mg"]
    #[doc = "     16g              |    (thres_u8 * 62.5) mg"]
    #[doc = ""]
    #[doc = "\t@note : SLOPE THRESHOLD"]
    #[doc = "\t@note Threshold of slope interrupt according to accel g range"]
    #[doc = "    g-range           |      Slope threshold"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     2g               |    (thres_u8 * 3.19) mg"]
    #[doc = "     4g               |    (thres_u8 * 7.81) mg"]
    #[doc = "     8g               |    (thres_u8 * 15.63) mg"]
    #[doc = "     16g              |    (thres_u8 * 31.25) mg"]
    #[doc = ""]
    #[doc = "\t@note : SLOW NO MOTION THRESHOLD"]
    #[doc = "\t@note Threshold of slow no motion interrupt according to accel g range"]
    #[doc = "    g-range           |   slow no motion threshold"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     2g               |    (thres_u8 * 3.19) mg"]
    #[doc = "     4g               |    (thres_u8 * 7.81) mg"]
    #[doc = "     8g               |    (thres_u8 * 15.63) mg"]
    #[doc = "     16g              |    (thres_u8 * 31.25) mg"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_thres(channel_u8: u8, thres_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe low high hysteresis in the registers 0x24"]
    #[doc = "\t@note LOW_G_HYST  -> bit form 0 to 1"]
    #[doc = "\t@note HIGH_G_HYST  -> bit from 6 to 7"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of hysteresis selection"]
    #[doc = "     channel_u8   | result"]
    #[doc = "   -----------------| ------------------"]
    #[doc = "           0        | BMA2x2_ACCEL_LOW_G_HYST"]
    #[doc = "           1        | BMA2x2_ACCEL_HIGH_G_HYST"]
    #[doc = ""]
    #[doc = "  @param hyst_u8: The hysteresis data"]
    #[doc = ""]
    #[doc = "\t@note LOW HYSTERESIS"]
    #[doc = "\t@note Hysteresis of low-g interrupt according to (hyst_u8 * 125)mg"]
    #[doc = ""]
    #[doc = "\t@note HIGH HYSTERESIS"]
    #[doc = "\t@note High hysteresis depends on the accel range selection"]
    #[doc = "    g-range           |    High Hysteresis"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     2g               |    (thres_u8 * 125) mg"]
    #[doc = "     4g               |    (thres_u8 * 250) mg"]
    #[doc = "     8g               |    (thres_u8 * 500) mg"]
    #[doc = "     16g              |    (thres_u8 * 1000) mg"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_low_high_g_hyst(channel_u8: u8, hyst_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe low high hysteresis in the registers 0x24"]
    #[doc = "\t@note LOW_G_HYST  -> bit form 0 to 1"]
    #[doc = "\t@note HIGH_G_HYST  -> bit from 6 to 7"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of hysteresis selection"]
    #[doc = "     channel_u8   | result"]
    #[doc = "   -----------------| ------------------"]
    #[doc = "           0        | BMA2x2_ACCEL_LOW_G_HYST"]
    #[doc = "           1        | BMA2x2_ACCEL_HIGH_G_HYST"]
    #[doc = ""]
    #[doc = "  @param hyst_u8: The hysteresis data"]
    #[doc = ""]
    #[doc = "\t@note LOW HYSTERESIS"]
    #[doc = "\t@note Hysteresis of low-g interrupt according to (hyst_u8 * 125)mg"]
    #[doc = ""]
    #[doc = "\t@note HIGH HYSTERESIS"]
    #[doc = "\t@note High hysteresis depends on the accel range selection"]
    #[doc = "    g-range           |    High Hysteresis"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     2g               |    (thres_u8 * 125) mg"]
    #[doc = "     4g               |    (thres_u8 * 250) mg"]
    #[doc = "     8g               |    (thres_u8 * 500) mg"]
    #[doc = "     16g              |    (thres_u8 * 1000) mg"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_low_high_g_hyst(channel_u8: u8, hyst_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tlow_g  mode in the registers 0x24 bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param low_g_mode_u8: The value of Low_G mode"]
    #[doc = "      low_g_mode_u8   |   g-result"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     0x00             | LOW_G_SINGLE_AXIS_MODE"]
    #[doc = "     0x01             | LOW_G_SUMMING_MODE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_low_g_mode(low_g_mode_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tlow_g  mode in the registers 0x24 bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param low_g_mode_u8: The value of Low_G mode"]
    #[doc = "    low_g_mode_u8   |    result"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     0x00             | LOW_G_SINGLE_AXIS_MODE"]
    #[doc = "     0x01             | LOW_G_SUMMING_MODE"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_set_low_g_mode(low_g_mode_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe tap duration in the register 0x2A bit form 0 to 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param tap_durn_u8: The value of tap duration"]
    #[doc = "    tap_durn_u8     |    result"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     0x00             | TAP_DURN_50_MS"]
    #[doc = "     0x01             | TAP_DURN_100_MS"]
    #[doc = "     0x02             | TAP_DURN_150_MS"]
    #[doc = "     0x03             | TAP_DURN_200_MS"]
    #[doc = "     0x04             | TAP_DURN_250_MS"]
    #[doc = "     0x05             | TAP_DURN_375_MS"]
    #[doc = "     0x06             | TAP_DURN_500_MS"]
    #[doc = "     0x07             | TAP_DURN_700_MS"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_tap_durn(tap_durn_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe tap duration in the register 0x2A bit form 0 to 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param tap_durn_u8: The value of tap duration"]
    #[doc = "    tap_durn_u8     |    result"]
    #[doc = "  --------------------|----------------------------"]
    #[doc = "     0x00             | TAP_DURN_50_MS"]
    #[doc = "     0x01             | TAP_DURN_100_MS"]
    #[doc = "     0x02             | TAP_DURN_150_MS"]
    #[doc = "     0x03             | TAP_DURN_200_MS"]
    #[doc = "     0x04             | TAP_DURN_250_MS"]
    #[doc = "     0x05             | TAP_DURN_375_MS"]
    #[doc = "     0x06             | TAP_DURN_500_MS"]
    #[doc = "     0x07             | TAP_DURN_700_MS"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_tap_durn(tap_durn_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe tap shock form the register 0x2A bit 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param tap_shock_u8: The value of tap shock"]
    #[doc = "    tap_shock_u8    |    result"]
    #[doc = "  --------------------|----------------------"]
    #[doc = "     0x00             | TAP_SHOCK_50_MS"]
    #[doc = "     0x01             | TAP_SHOCK_75_MS"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_tap_shock(tap_shock_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe tap shock form the register 0x2A bit 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param tap_shock_u8: The value of tap shock"]
    #[doc = "    tap_shock_u8    |    result"]
    #[doc = "  --------------------|----------------------"]
    #[doc = "     0x00             | TAP_SHOCK_50_MS"]
    #[doc = "     0x01             | TAP_SHOCK_75_MS"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_set_tap_shock(tap_shock_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe tap quiet in the register 0x2A bit 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  tap_quiet_u8 : The value of tap quiet"]
    #[doc = "    tap_quiet_u8    |    result"]
    #[doc = "  --------------------|----------------------"]
    #[doc = "     0x00             | TAP_QUIET_30_MS"]
    #[doc = "     0x01             | TAP_QUIET_20_MS"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_tap_quiet(tap_quiet_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe tap quiet in the register 0x2A bit 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  tap_quiet_u8 : The value of tap quiet"]
    #[doc = "    tap_quiet_u8    |    result"]
    #[doc = "  --------------------|----------------------"]
    #[doc = "     0x00             | TAP_QUIET_30_MS"]
    #[doc = "     0x01             | TAP_QUIET_20_MS"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_tap_quiet(tap_quiet_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe tap threshold in the register 0x2B bit from 0 to 4"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param tap_thres_u8 : The value of tap threshold"]
    #[doc = "  @note Tap threshold of single and double tap corresponding"]
    #[doc = "       to accel range"]
    #[doc = "     range            |    Tap threshold"]
    #[doc = "  --------------------|----------------------"]
    #[doc = "     2g               | (tap_thres_u8 * 62.5)mg"]
    #[doc = "     4g               | (tap_thres_u8 * 125)mg"]
    #[doc = "     8g               | (tap_thres_u8 * 250)mg"]
    #[doc = "     16g              | (tap_thres_u8 * 500)mg"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_tap_thres(tap_thres_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe tap threshold in the register 0x2B bit from 0 to 4"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param tap_thres_u8 : The value of tap threshold"]
    #[doc = "  @note Tap threshold of single and double tap corresponding"]
    #[doc = "       to accel range"]
    #[doc = "     range            |    Tap threshold"]
    #[doc = "  --------------------|----------------------"]
    #[doc = "     2g               | (tap_thres_u8 * 62.5)mg"]
    #[doc = "     4g               | (tap_thres_u8 * 125)mg"]
    #[doc = "     8g               | (tap_thres_u8 * 250)mg"]
    #[doc = "     16g              | (tap_thres_u8 * 500)mg"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_tap_thres(tap_thres_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe tap sample in the register 0x2B bit 6 and 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param   *tap_sample_u8 : The value of tap sample"]
    #[doc = "     tap_sample_u8  |    result"]
    #[doc = "  --------------------|----------------------"]
    #[doc = "     0x00             | 2 samples"]
    #[doc = "     0x01             | 4 samples"]
    #[doc = "     0x02             | 8 samples"]
    #[doc = "     0x03             | 16 samples"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_tap_sample(tap_sample_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe tap sample in the register 0x2B bit 6 and 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param   *tap_sample_u8 : The value of tap sample"]
    #[doc = "     tap_sample_u8  |    result"]
    #[doc = "  --------------------|----------------------"]
    #[doc = "     0x00             | 2 samples"]
    #[doc = "     0x01             | 4 samples"]
    #[doc = "     0x02             | 8 samples"]
    #[doc = "     0x03             | 16 samples"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_tap_sample(tap_sample_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe orient mode in the register 0x2C bit 0 and 1"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param orient_mode_u8 : The value of orient mode"]
    #[doc = "     orient_mode_u8 |    result"]
    #[doc = "  --------------------|------------------"]
    #[doc = "     0x00             | symmetrical"]
    #[doc = "     0x01             | high asymmetrical"]
    #[doc = "     0x02             | low asymmetrical"]
    #[doc = "     0x03             | symmetrical"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_orient_mode(orient_mode_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe orient mode in the register 0x2C bit 0 and 1"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param orient_mode_u8 : The value of orient mode"]
    #[doc = "     orient_mode_u8 |    result"]
    #[doc = "  --------------------|------------------"]
    #[doc = "     0x00             | symmetrical"]
    #[doc = "     0x01             | high asymmetrical"]
    #[doc = "     0x02             | low asymmetrical"]
    #[doc = "     0x03             | symmetrical"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_set_orient_mode(orient_mode_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe orient block in the register 0x2C bit 2 and 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param orient_block_u8 : The value of orient block"]
    #[doc = "     orient_mode_u8 |    result"]
    #[doc = "  --------------------|------------------"]
    #[doc = "     0x00             | no blocking"]
    #[doc = "     0x01             | theta blocking or"]
    #[doc = "                      | acceleration slope in any axis > 1.5g"]
    #[doc = "     0x02             | theta blocking or"]
    #[doc = "                      | acceleration slope in any axis > 0.2g"]
    #[doc = "                      | acceleration in any axis > 1.5g"]
    #[doc = "     0x03             | theta blocking or"]
    #[doc = "                      | acceleration slope in any axis > 0.4g"]
    #[doc = "                      | acceleration in any axis > 1.5g"]
    #[doc = "                      | value of orient is not stable for at lease 100ms"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_orient_block(orient_block_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe orient block in the register 0x2C bit 2 and 3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param orient_block_u8 : The value of orient block"]
    #[doc = "     orient_mode_u8 |    result"]
    #[doc = "  --------------------|------------------"]
    #[doc = "     0x00             | no blocking"]
    #[doc = "     0x01             | theta blocking or"]
    #[doc = "                      | acceleration slope in any axis > 1.5g"]
    #[doc = "     0x02             | theta blocking or"]
    #[doc = "                      | acceleration slope in any axis > 0.2g"]
    #[doc = "                      | acceleration in any axis > 1.5g"]
    #[doc = "     0x03             | theta blocking or"]
    #[doc = "                      | acceleration slope in any axis > 0.4g"]
    #[doc = "                      | acceleration in any axis > 1.5g"]
    #[doc = "                      | value of orient is not stable for at lease 100ms"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_orient_block(orient_block_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe orient hysteresis in the register 0x2C bit 4 to 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param orient_hyst_u8 : The value of orient hysteresis"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_orient_hyst(orient_hyst_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe orient hysteresis in the register 0x2C bit 4 to 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param orient_hyst_u8 : The value of orient hysteresis"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_orient_hyst(orient_hyst_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief  This API is used to get"]
    #[doc = "\tthe theta value of orient and flat interrupts"]
    #[doc = "\t@note ORIENT_THETA -> register 0x2D bit 0 to 5"]
    #[doc = "\t@note FLAT_THETA   -> register 0x2E bit 0 to 5"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of theta selection"]
    #[doc = "     channel_u8     |    result"]
    #[doc = "  --------------------|------------------"]
    #[doc = "     0x00             | BMA2x2_ACCEL_ORIENT_THETA"]
    #[doc = "     0x01             | BMA2x2_ACCEL_FLAT_THETA"]
    #[doc = " @note"]
    #[doc = " @note FLAT_THETA : Defines a blocking angle between 0 deg to 44.8 deg"]
    #[doc = " @note ORIENT_THETA : Defines threshold for detection of flat position"]
    #[doc = "                in range from 0 deg to 44.8 deg"]
    #[doc = ""]
    #[doc = "  @param theta_u8: The value of theta"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_theta(channel_u8: u8, theta_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief  This API is used to set"]
    #[doc = "\tthe theta value of orient and flat interrupts"]
    #[doc = "\t@note ORIENT_THETA -> register 0x2D bit 0 to 5"]
    #[doc = "\t@note FLAT_THETA   -> register 0x2E bit 0 to 5"]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of theta selection"]
    #[doc = "     channel_u8     |    result"]
    #[doc = "  --------------------|------------------"]
    #[doc = "     0x00             | BMA2x2_ACCEL_ORIENT_THETA"]
    #[doc = "     0x01             | BMA2x2_ACCEL_FLAT_THETA"]
    #[doc = " @note"]
    #[doc = " @note FLAT_THETA : Defines a blocking angle between 0 deg to 44.8 deg"]
    #[doc = " @note ORIENT_THETA : Defines threshold for detection of flat position"]
    #[doc = "                in range from 0 deg to 44.8 deg"]
    #[doc = ""]
    #[doc = "  @param theta_u8: The value of theta"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_theta(channel_u8: u8, theta_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "  the interrupt enable of orient ud_enable in the register 0x2D bit 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param orient_enable_u8 : The value of orient ud_enable"]
    #[doc = "     orient_enable_u8     |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | Generates Interrupt"]
    #[doc = "     0x01                   | Do not generate interrupt"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_orient_enable(orient_enable_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "  the interrupt enable of orient ud_enable in the register 0x2D bit 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param orient_enable_u8 : The value of orient ud_enable"]
    #[doc = "     orient_enable_u8     |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | Generates Interrupt"]
    #[doc = "     0x01                   | Do not generate interrupt"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_orient_enable(orient_enable_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe interrupt enable of flat hysteresis(\"flat_hy)"]
    #[doc = "\tin the register 0x2F bit 0 to 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param flat_hyst_u8 : The value of flat hysteresis"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_flat_hyst(flat_hyst_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe interrupt enable of flat hysteresis(\"flat_hy)"]
    #[doc = "\tin the register 0x2F bit 0 to 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param flat_hyst_u8 : The value of flat hysteresis"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_flat_hyst(flat_hyst_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "  the interrupt enable of flat hold time(flat_hold_time)"]
    #[doc = "\tin the register 0x2F bit 4 and 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  flat_hold_time_u8 : The value of flat hold time"]
    #[doc = "     flat_hold_time_u8    |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | 0ms"]
    #[doc = "     0x01                   | 512ms"]
    #[doc = "     0x02                   | 1024ms"]
    #[doc = "     0x03                   | 2048ms"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_flat_hold_time(flat_hold_time_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "  the interrupt enable of flat hold time(flat_hold_time)"]
    #[doc = "\tin the register 0x2F bit 4 and 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  flat_hold_time_u8 : The value of flat hold time"]
    #[doc = "     flat_hold_time_u8    |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | 0ms"]
    #[doc = "     0x01                   | 512ms"]
    #[doc = "     0x02                   | 1024ms"]
    #[doc = "     0x03                   | 2048ms"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_flat_hold_time(flat_hold_time_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe fifo water mark level trigger in the register 0x30 bit from 0 to 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_wml_trig: The value of fifo watermark trigger level"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_fifo_wml_trig(fifo_wml_trig: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe fifo water mark level trigger in the register 0x30 bit from 0 to 5"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_wml_trig: The value of fifo watermark trigger level"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_fifo_wml_trig(fifo_wml_trig: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is for to get"]
    #[doc = "\tthe self test axis(self_test_axis) in the register ox32 bit 0 to 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param selftest_axis_u8 : The value of selftest axis"]
    #[doc = "     selftest_axis_u8     |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | self test disable"]
    #[doc = "     0x01                   | x-axis"]
    #[doc = "     0x02                   | y-axis"]
    #[doc = "     0x03                   | z-axis"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_selftest_axis(selftest_axis_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is for to set"]
    #[doc = "\tthe self test axis(self_test_axis) in the register ox32 bit 0 to 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param selftest_axis_u8 : The value of selftest axis"]
    #[doc = "     selftest_axis_u8     |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | self test disable"]
    #[doc = "     0x01                   | x-axis"]
    #[doc = "     0x02                   | y-axis"]
    #[doc = "     0x03                   | z-axis"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_selftest_axis(selftest_axis_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is for to get"]
    #[doc = "\tthe Self Test sign(selftest_sign) in the register 0x32 bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param selftest_sign_u8 : The value of self test sign"]
    #[doc = "     selftest_sign_u8     |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | negative sign"]
    #[doc = "     0x01                   | positive sign"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_selftest_sign(selftest_sign_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is for to set"]
    #[doc = "\tthe Self Test sign(selftest_sign) in the register 0x32 bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param selftest_sign_u8 : The value of self test sign"]
    #[doc = "     selftest_sign_u8     |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | negative sign"]
    #[doc = "     0x01                   | positive sign"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_selftest_sign(selftest_sign_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the nvm program mode(nvm_prog_mode)in the register 0x33 bit 0"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  nvmprog_mode_u8 : The value of nvm program mode"]
    #[doc = "     nvmprog_mode_u8      |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | Disable program mode"]
    #[doc = "     0x01                   | Enable program mode"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_nvmprog_mode(nvmprog_mode_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the nvm program mode(nvm_prog_mode)in the register 0x33 bit 0"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  nvmprog_mode_u8 : The value of nvm program mode"]
    #[doc = "     nvmprog_mode_u8      |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | Disable program mode"]
    #[doc = "     0x01                   | Enable program mode"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_nvmprog_mode(nvmprog_mode_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe value of nvm program trig in the register 0x33 bit 1"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param nvprog_trig_u8: The value of nvm program trig"]
    #[doc = "     nvprog_trig_u8       |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | Do not trigger nvm program"]
    #[doc = "     0x01                   | Trigger nvm program"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_nvprog_trig(nvprog_trig_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the nvm program ready in the register bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param nvprog_ready_u8: The value of nvm program ready"]
    #[doc = "     nvprog_ready_u8      |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | nvm write/update operation is in progress"]
    #[doc = "     0x01                   | nvm is ready to accept a new write"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_nvmprog_ready(nvprog_ready_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the nvm program ready in the register bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param nvprog_remain_u8: The value of nvm program ready"]
    #[doc = "     nvprog_remain_u8     |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | nvm write/update operation is in progress"]
    #[doc = "     0x01                   | nvm is ready to accept a new write"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_nvmprog_remain(nvprog_remain_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get the enable status of spi3"]
    #[doc = "\tin the register 0x34 bit 0"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  spi3_u8 : The value of SPI 3 or 4 wire enable"]
    #[doc = "     spi3_u8              |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   |     spi4"]
    #[doc = "     0x01                   |     spi3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_spi3(spi3_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set the enable status of spi3"]
    #[doc = "\tin the register 0x34 bit 0"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  spi3_u8 : The value of SPI 3 or 4 wire enable"]
    #[doc = "     spi3_u8              |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   |     spi4"]
    #[doc = "     0x01                   |     spi3"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_spi3(spi3_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get the i2c"]
    #[doc = "\twatch dog timer period and I2C interface mode is selected"]
    #[doc = "\tin the register 0x34 bit 1 and 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The i2c option selection"]
    #[doc = "     channel_u8           |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   BMA2x2_ACCEL_I2C_SELECT"]
    #[doc = "        1                   |   BMA2x2_ACCEL_I2C_ENABLE"]
    #[doc = ""]
    #[doc = "  @param i2c_wdt_u8: watch dog timer period"]
    #[doc = "\tand I2C interface mode is selected"]
    #[doc = "     BMA2x2_ACCEL_I2C_SELECT|    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | Disable the watchdog at SDI pin"]
    #[doc = "     0x01                   | Enable watchdog"]
    #[doc = ""]
    #[doc = "     BMA2x2_I2C_ENABLE      |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | 1ms"]
    #[doc = "     0x01                   | 50ms"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_i2c_wdt(channel_u8: u8, i2c_wdt_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set the i2c"]
    #[doc = "\twatch dog timer period and I2C interface mode is selected"]
    #[doc = "\tin the register 0x34 bit 1 and 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The i2c option selection"]
    #[doc = "     channel_u8           |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   BMA2x2_ACCEL_I2C_SELECT"]
    #[doc = "        1                   |   BMA2x2_ACCEL_I2C_ENABLE"]
    #[doc = ""]
    #[doc = "  @param i2c_wdt_u8: watch dog timer period"]
    #[doc = "\tand I2C interface mode is selected"]
    #[doc = "     BMA2x2_ACCEL_I2C_SELECT|    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | Disable the watchdog at SDI pin"]
    #[doc = "     0x01                   | Enable watchdog"]
    #[doc = ""]
    #[doc = "     BMA2x2_I2C_ENABLE      |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "     0x00                   | 1ms"]
    #[doc = "     0x01                   | 50ms"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_i2c_wdt(channel_u8: u8, i2c_wdt_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tslow compensation(hp_x_enable, hp_y_enable and hp_z_enable) enable"]
    #[doc = "\tin the register 0x36 bit 0 to 2"]
    #[doc = "\t@note SLOW_COMP_X -> bit 0"]
    #[doc = "\t@note SLOW_COMP_Y -> bit 1"]
    #[doc = "\t@note SLOW_COMP_Z -> bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param channel_u8: The value of slow compensation selection"]
    #[doc = "     channel_u8           |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   BMA2x2_ACCEL_SLOW_COMP_X"]
    #[doc = "        1                   |   BMA2x2_ACCEL_SLOW_COMP_Y"]
    #[doc = "        2                   |   BMA2x2_ACCEL_SLOW_COMP_Z"]
    #[doc = ""]
    #[doc = "  @param slow_comp_u8: The value of slow compensation enable"]
    #[doc = "     slow_comp_u8         |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "         0x00               |    Disable"]
    #[doc = "        0x01                |    Enable"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_slow_comp(channel_u8: u8, slow_comp_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tslow compensation(hp_x_enable, hp_y_enable and hp_z_enable) enable"]
    #[doc = "\tin the register 0x36 bit 0 to 2"]
    #[doc = "\t@note SLOW_COMP_X -> bit 0"]
    #[doc = "\t@note SLOW_COMP_Y -> bit 1"]
    #[doc = "\t@note SLOW_COMP_Z -> bit 2"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@param channel_u8: The value of slow compensation selection"]
    #[doc = "     channel_u8           |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   BMA2x2_ACCEL_SLOW_COMP_X"]
    #[doc = "        1                   |   BMA2x2_ACCEL_SLOW_COMP_Y"]
    #[doc = "        2                   |   BMA2x2_ACCEL_SLOW_COMP_Z"]
    #[doc = ""]
    #[doc = "  @param slow_comp_u8: The value of slow compensation enable"]
    #[doc = "     slow_comp_u8         |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "         0x00               |    Disable"]
    #[doc = "        0x01                |    Enable"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_slow_comp(channel_u8: u8, slow_comp_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe status of fast offset compensation(cal_rdy) in the register 0x36"]
    #[doc = "\tbit 4(Read Only Possible)"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  cal_rdy_u8: The value of cal_ready"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_cal_rdy(cal_rdy_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe status of fast offset compensation(cal_rdy) in the register 0x36"]
    #[doc = "\tbit 4(Read Only Possible)"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  cal_trigger_u8: The value of cal_ready"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_cal_trigger(cal_trigger_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe offset reset(offset_reset) in the register 0x36"]
    #[doc = "\tbit 7(Write only possible)"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  offset_rst_u8: The offset reset value"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_offset_rst(offset_rst_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe status of offset target axis(offset_target_x, offset_target_y and"]
    #[doc = "\toffset_target_z) and cut_off in the register 0x37"]
    #[doc = "\t@note CUT_OFF -> bit 0"]
    #[doc = "\t@note OFFSET_TRIGGER_X -> bit 1 and 2"]
    #[doc = "\t@note OFFSET_TRIGGER_Y -> bit 3 and 4"]
    #[doc = "\t@note OFFSET_TRIGGER_Z -> bit 5 and 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of offset axis selection"]
    #[doc = "     channel_u8           |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   BMA2x2_ACCEL_CUT_OFF"]
    #[doc = "        1                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_X"]
    #[doc = "        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Y"]
    #[doc = "        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Z"]
    #[doc = ""]
    #[doc = "  @param  offset_u8: The offset target value"]
    #[doc = "     CUT_OFF                |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   1Hz"]
    #[doc = "        1                   |   10Hz"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "     OFFSET_TRIGGER         |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0x00                |   0g"]
    #[doc = "        0x01                |   +1g"]
    #[doc = "        0x02                |   -1g"]
    #[doc = "        0x03                |   0g"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_offset_target(channel_u8: u8, offset_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe status of offset target axis(offset_target_x, offset_target_y and"]
    #[doc = "\toffset_target_z) and cut_off in the register 0x37"]
    #[doc = "\t@note CUT_OFF -> bit 0"]
    #[doc = "\t@note OFFSET_TRIGGER_X -> bit 1 and 2"]
    #[doc = "\t@note OFFSET_TRIGGER_Y -> bit 3 and 4"]
    #[doc = "\t@note OFFSET_TRIGGER_Z -> bit 5 and 6"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of offset axis selection"]
    #[doc = "     channel_u8           |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   BMA2x2_ACCEL_CUT_OFF"]
    #[doc = "        1                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_X"]
    #[doc = "        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Y"]
    #[doc = "        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Z"]
    #[doc = ""]
    #[doc = "  @param  offset_u8: The offset target value"]
    #[doc = "     CUT_OFF                |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   1Hz"]
    #[doc = "        1                   |   10Hz"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "     OFFSET_TRIGGER         |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0x00                |   0g"]
    #[doc = "        0x01                |   +1g"]
    #[doc = "        0x02                |   -1g"]
    #[doc = "        0x03                |   0g"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_offset_target(channel_u8: u8, offset_u8: u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get the status of offset"]
    #[doc = "\t(offset_x, offset_y and offset_z) in the registers 0x38,0x39 and 0x3A"]
    #[doc = "\t@note offset_x -> register 0x38 bit 0 to 7"]
    #[doc = "\t@note offset_y -> register 0x39 bit 0 to 7"]
    #[doc = "\t@note offset_z -> register 0x3A bit 0 to 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of offset selection"]
    #[doc = "     channel_u8           |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   BMA2x2_ACCEL_X_AXIS"]
    #[doc = "        1                   |   BMA2x2_ACCEL_Y_AXIS"]
    #[doc = "        2                   |   BMA2x2_ACCEL_Z_AXIS"]
    #[doc = ""]
    #[doc = "  @param offset_u8: The value of offset"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_offset(channel_u8: u8, offset_u8: *mut s8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set the status of offset"]
    #[doc = "\t(offset_x, offset_y and offset_z) in the registers 0x38,0x39 and 0x3A"]
    #[doc = "\t@note offset_x -> register 0x38 bit 0 to 7"]
    #[doc = "\t@note offset_y -> register 0x39 bit 0 to 7"]
    #[doc = "\t@note offset_z -> register 0x3A bit 0 to 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param channel_u8: The value of offset selection"]
    #[doc = "     channel_u8           |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0                   |   BMA2x2_ACCEL_X_AXIS"]
    #[doc = "        1                   |   BMA2x2_ACCEL_Y_AXIS"]
    #[doc = "        2                   |   BMA2x2_ACCEL_Z_AXIS"]
    #[doc = ""]
    #[doc = "  @param offset_u8: The value of offset"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_offset(channel_u8: u8, offset_u8: s8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe status of fifo (fifo_mode) in the register 0x3E bit 6 and 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_mode_u8 : The value of fifo mode"]
    #[doc = "     fifo_mode_u8         |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0x00                |   BYPASS"]
    #[doc = "        0x01                |   FIFO"]
    #[doc = "        0x02                |   STREAM"]
    #[doc = "        0x03                |   RESERVED"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_fifo_mode(fifo_mode_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to set"]
    #[doc = "\tthe status of fifo (fifo_mode) in the register 0x3E bit 6 and 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_mode_u8 : The value of fifo mode"]
    #[doc = "     fifo_mode_u8         |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0x00                |   BYPASS"]
    #[doc = "        0x01                |   FIFO"]
    #[doc = "        0x02                |   STREAM"]
    #[doc = "        0x03                |   RESERVED"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_set_fifo_mode(fifo_mode_u8: u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to get"]
    #[doc = " the axis enable of fifo data select in the register 0x3E bit 0 and 1"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_data_select_u8 : The value of FIFO axis data select"]
    #[doc = "   fifo_data_select_u8    |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0x00                |   XYZ"]
    #[doc = "        0x01                |   Y"]
    #[doc = "        0x02                |   X"]
    #[doc = "        0x03                |   Z"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_get_fifo_data_select(fifo_data_select_u8: *mut u8) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to set"]
    #[doc = " the axis enable of fifo data select in the register 0x3E bit 0 and 1"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param fifo_data_select_u8 : The value of FIFO axis data select"]
    #[doc = "   fifo_data_select_u8    |    result"]
    #[doc = "  ------------------------- |------------------"]
    #[doc = "        0x00                |   XYZ"]
    #[doc = "        0x01                |   Y"]
    #[doc = "        0x02                |   X"]
    #[doc = "        0x03                |   Z"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    #[doc = ""]
    pub fn bma2x2_set_fifo_data_select(fifo_data_select_u8: u8) -> s8;
}
extern "C" {
    #[doc = "  @brief This API reads the FIFO data from the register 0x3F"]
    #[doc = "  and store the data in the user defined buffer mapped to the member"]
    #[doc = "  of structure \"fifo_configuration\""]
    #[doc = ""]
    #[doc = "  @note Before calling this API user must map the following FIFO settings"]
    #[doc = "  required to read the FIFO data to the structure \"fifo_configuration\""]
    #[doc = "    - Data buffer to store the FIFO data is mapped to"]
    #[doc = "      the structure member \"fifo_data\""]
    #[doc = "    - Number of bytes to be read from FIFO is mapped to"]
    #[doc = "      the structure member \"fifo_length\""]
    #[doc = ""]
    #[doc = "  @note The number of bytes to be read from the FIFO is specified in the"]
    #[doc = "  member \"fifo_length\" of the structure \"fifo_configuration\""]
    #[doc = ""]
    #[doc = "  @param[in,out] fifo_conf : Structure containing the FIFO configurations"]
    #[doc = "  is passed as input and FIFO data of specified length is obtained as output"]
    #[doc = ""]
    #[doc = "  @return results of bus communication function"]
    #[doc = "  @retval 0 -> Success"]
    #[doc = "  @retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_fifo_data(fifo_conf: *mut fifo_configuration) -> s8;
}
extern "C" {
    #[doc = "  @brief This API extracts the accel data from the FIFO frames"]
    #[doc = ""]
    #[doc = "  @note The bma2x2_extract_accel() API should be called only after reading"]
    #[doc = "  the FIFO data by calling the bma2x2_read_fifo_data() API"]
    #[doc = ""]
    #[doc = "  @param[in,out] accel_frame      : Instance of the union where accel data"]
    #[doc = "                                    in FIFO is parsed and stored"]
    #[doc = ""]
    #[doc = "  @param[in,out] accel_frame_count: Number of Accel frames requested by user"]
    #[doc = "                                    is got as input and number of"]
    #[doc = "                                    accel frames parsed and stored is"]
    #[doc = "                                    returned as output to user"]
    #[doc = ""]
    #[doc = "  @param[in, out] fifo_conf       : FIFO configuration structure."]
    #[doc = "                                    It provides the following as input"]
    #[doc = "                                        - user defined buffer"]
    #[doc = "                                        - length of FIFO data read"]
    #[doc = "                                    It returns the accel_byte_start_index"]
    #[doc = "                                    (index of accel bytes parsed from FIFO)"]
    #[doc = ""]
    #[doc = "  @return results of API execution status"]
    #[doc = "  @retval 0 -> Success"]
    #[doc = "  @retval -127 -> Error"]
    #[doc = ""]
    pub fn bma2x2_extract_accel(
        accel_frame: *mut fifo_frame,
        accel_frame_count: *mut u8,
        fifo_conf: *mut fifo_configuration,
    ) -> s8;
}
extern "C" {
    #[doc = " @brief This API is used to read the temp"]
    #[doc = " from register 0x08"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  temp_s8: The value of temperature"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_temp(temp_s8: *mut s8) -> s8;
}
extern "C" {
    #[doc = " @brief This API reads accelerometer data X,Y,Z values and"]
    #[doc = " temperature data from location 02h to 08h"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param accel : The value of accel xyz and temperature data"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_accel_xyzt(accel: *mut bma2x2_accel_data_temp) -> s8;
}
extern "C" {
    #[doc = " @brief This API reads accelerometer data X,Y,Z values and"]
    #[doc = " temperature data from location 0x02 to 0x08"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param accel : The value of accel xyz and temperature data"]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_read_accel_eight_resolution_xyzt(
        accel: *mut bma2x2_accel_eight_resolution_temp,
    ) -> s8;
}
extern "C" {
    #[doc = "\t@brief This API is used to get"]
    #[doc = "\tthe fifo data in the register 0x3F bit 0 to 7"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @param  output_reg_u8 : The value of fifo data"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "\t@return results of bus communication function"]
    #[doc = "\t@retval 0 -> Success"]
    #[doc = "\t@retval -1 -> Error"]
    #[doc = ""]
    pub fn bma2x2_get_fifo_data_output_reg(output_reg_u8: *mut u8) -> s8;
}
